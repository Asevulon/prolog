<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 3. Пункт 3</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch3_2.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch3_4.htm">Вперёд</a></p>
<a name="tn184"><script language="JavaScript">double_line();</script>


<h4>3. 3.&nbsp;&nbsp;&nbsp; <span id="t184">Операторная запись
(нотация)</span></h4>

<p>В математике мы привыкли записывать выражения
в таком виде:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>2*a&nbsp; +&nbsp; b*с</em></p>

<p>где&nbsp; <em>+</em>&nbsp; и&nbsp; <em>*</em>&nbsp; - это операторы, а
&nbsp;&nbsp; <em>2</em>,<em>&nbsp;&nbsp; а</em>,<em>&nbsp;&nbsp; b</em>,<em> &nbsp;&nbsp;
с</em>&nbsp;&nbsp; - аргументы. В частности,&nbsp; <em>+</em> &nbsp;
и&nbsp; *&nbsp; называют <em>инфиксными</em> операторами,
поскольку они появляются <em>между</em> своими
аргументами. Такие выражения могут быть</a><a
name="tn187"> представлены в виде деревьев, как это
сделано на рис. 3.6, и <span id="t187">записаны как
прологовские термы</span> с&nbsp; <em>+</em> &nbsp; и&nbsp; <em>*</em>&nbsp;
в качестве функторов:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>+( *( 2, а), *( b, с) )</strong></p>
</a>

<p align="center"><img src="pic/fig3_6.gif" width="293" height="152"
alt="fig3_6.gif (733 bytes)"></p>
<a name="tn187">

<p align="center"><small><strong>Рис. 3. 6.</strong>&nbsp; Представление
выражения&nbsp; 2*а+b*с&nbsp; в виде дерева.</small></p>

<p>Поскольку мы обычно предпочитаем записывать
такие выражения в привычной инфиксной форме
операторов, Пролог обеспечивает такое удобство.
Поэтому наше выражение, записанное просто как</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>2*а&nbsp; +&nbsp; b*с</strong></p>

<p>будет воспринято правильно. Однако это лишь
внешнее представление объекта, которое будет
автоматически преобразовано в обычную форму
прологовских термов. Такой терм выводится
пользователю снова в своей внешней инфиксной
форме. </p>

<p>Выражения рассматриваются Прологом просто как
дополнительный способ записи, при котором не
вводятся какие-либо новые принципы
структуризации объектов данных. Если мы напишем
&nbsp; <strong>а&nbsp; +&nbsp; b</strong>,&nbsp; Пролог поймет эту
запись, как если бы написали <strong>+(а, b)</strong>. Для
того, чтобы Пролог правильно воспринимал
выражения типа <strong>а + b*с</strong>, он должен знать,
что <strong>*</strong> связывает сильнее, чем <strong>+</strong>.
Будем говорить, что + имеет более низкий
приоритет, чем *. Поэтому верная интерпретация
выражений зависит от приоритетов операторов.
Например, выражение <strong>а&nbsp; +&nbsp; b*с</strong>, в
принципе можно понимать и как</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>+( а, *( b, с) )</strong></p>

<p>и как</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>*( +( а, b), с</a><a name="tn189">)</strong></p>

<p><span id="t189">Общее правило состоит в том, что</span>
оператор с самым низким приоритетом
расценивается как главный функтор терма. Если мы
хотим, чтобы выражения, содержащие&nbsp; +&nbsp; и&nbsp; *,
&nbsp; понимались в соответствии с обычными
соглашениями, то&nbsp; + должен иметь более низкий
приоритет, чем&nbsp; *.&nbsp; Тогда выражение <strong>а&nbsp; +
&nbsp; b*с</strong> означает то же, что и <strong>а&nbsp; +&nbsp; (b*с)</strong>.
Если имеется в виду другая интерпретация, то это
надо указать явно с помощью скобок, например <strong>(
а+b)*с</strong>.</p>

<p>Программист может вводить свои собственные
операторы. Так, например, можно определить атомы <strong>имеет</strong>
и <strong>поддерживает</strong> в качестве инфиксных
операторов, а затем записывать в программе факты
вида:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>питер имеет
информацию.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; пол поддерживает стол.</strong></p>

<p>Эти факты в точности эквивалентны следующим:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>имеет( питер,
информацию).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; поддерживает( пол, стол).</strong></p>

<p>Программист определяет новые операторы, вводя
в программу особый вид предложений, которые
иногда называют <em>директивами</em>. Такие
предложения играют роль определений новых
операторов. Определение оператора должно
появиться в программе раньше, чем любое
выражение, использующее этот оператор. Например,
оператор имеет можно определить директивой</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>:- ор( 600, xfx, имеет).</strong></p>

<p>Такая запись сообщит Прологу, что мы хотим
использовать &quot;имеет&quot; в качестве оператора с
приоритетом 600 и типом 'xfx', обозначающий одну из
разновидностей инфиксного оператора. Форма
спецификатора 'xfx' указывает на то, что оператор,
обозначенный через 'f', располагается между
аргументами, обозначенными через 'х'. </p>

<p>Обратите внимание на то, что определения
операторов не содержат описания каких-либо
операций или действий. В соответствии с
принципами языка <em>ни</em> с <em>одним оператором не
связывается каких-либо операций над данными</em>
(за исключением особых, редких случаев).
Операторы обычно используются так же, как и
функторы, только для объединения объектов в
структуры и не вызывают действия над данными,
хотя само слово &quot;оператор&quot;, казалось бы,
должно подразумевать какое-то действие. </p>

<p>Имена операторов это атомы, а их приоритеты -
точнее, номера их приоритетов -&nbsp; должны
находиться в некотором диапазоне, зависящем от
реализации. Мы будем считать, что этот диапазон
располагается в пределах от 1 до 1200.(<small>Чем выше
приоритет, тем меньше его номер.&nbsp; -&nbsp; <em>Прим.
перев</a><a name="tn191">.</em></small>)</p>

<p><span id="t191">Существуют три группы типов
операторов</span>, обозначаемые спецификаторами,
похожими на <strong>xfx</strong>:</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; инфиксные операторы
трех типов:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>xfx
&nbsp;&nbsp;&nbsp; xfy&nbsp;&nbsp;&nbsp; yfx</strong></p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; префиксные операторы
двух типов:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>fx
&nbsp;&nbsp;&nbsp; fy</strong></p>

<p>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; постфиксные операторы
двух типов:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>хf
&nbsp;&nbsp;&nbsp; yf</strong></p>

<p>Спецификаторы выбраны с таким расчетом, чтобы
нагляднее отразить структуру выражения, в
котором 'f' соответствует оператору, а 'х' и 'у'
представляют его аргументы. Расположение 'f'
между аргументами указывает на то, что оператор
инфиксный. Префиксные и постфиксные
спецификаторы содержат только один аргумент,
который, соответственно, либо следует за
оператором, либо предшествует ему.</p>

<p align="center"><img src="pic/fig3_7.gif" width="488" height="217"
alt="fig3_7.gif (2279 bytes)"></p>

<p align="center"><small><strong>Рис. 3. 7.</strong>&nbsp; Две
интерпретации выражения <strong>а-b-с</strong> в
предположении, что '-' имеет приоритет 500. Если тип
'-' есть <strong>yfx</strong>, то интерпретация 2 неверна,
так как приоритет <strong>b-с</strong> не выше, чем
приоритет '-'.</small></p>

<p>Между 'х' и 'у' есть разница. Для ее объяснения
нам потребуется ввести понятие <em>приоритета
аргумента</em>. Если аргумент заключен в скобки или
не имеет структуры (является простым объектом),
тогда его приоритет равен 0; если же он
структурный, тогда его приоритет равен
приоритету его главного функтора. С помощью 'х'
обозначается аргумент, чей приоритет должен быть
строго выше приоритета оператора (т. е. его номер
строго меньше номера приоритета оператора); с
помощью 'у' обозначается аргумент, чей приоритет
выше или равен приоритету оператора.</p>

<p>Такие правила помогают избежать
неоднозначности при обработке выражений, в
которых встречаются операторы с одинаковым
приоритетом. Например, выражение</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>а-b-с</strong></p>

<p>обычно понимается как <strong>(а-b)-с</strong> , а не как <strong>а-(b-с)</strong>.
Чтобы обеспечить такую обычную интерпретацию,
оператор '-' следует определять как <strong>yfx</strong>. На
рис. 3.7 показано, каким образом исключается
вторая интерпретация.</p>

<p>В качестве еще одного примера рассмотрим
оператор <strong>not</strong> (логическое отрицание
&quot;не&quot;). Если <strong>not</strong> oпределён как <strong>fy</strong>,
тогда выражение</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>not&nbsp; not&nbsp; р</strong></p>

<p>записано верно; однако, если <strong>not</strong>
определен как <strong>fx</strong>, оно некорректно, потому
что аргументом первого <strong>not</strong> является
структура <strong>not p</strong>, которая имеет тот же
приоритет, что и <strong>not</strong>. В этом случае
выражение следует писать со скобками:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>not&nbsp; (not&nbsp; р)</strong></p>
<script language="JavaScript">line();</script>


<p><strong>:- ор( 1200, xfx, ':-').</strong></p>

<p><strong>:- ор( 1200, fx, [:-, ?-] ).</strong></p>

<p><strong>:- op( 1100, xfy, ';').</strong></p>

<p><strong>:- ор( 1000, xfy, ',').</strong></p>

<p><strong>:- op( 700, xfx, [=, is, &lt;<,>, &gt;, =&lt;, &gt;=, ==, =\=, \==, =:=]).</strong></p>

<p><strong>:- op( 500, yfx, [+, -] ).</strong></p>

<p><strong>:- op( 500, fx, [+, -, not] ).</strong></p>

<p><strong>:- op( 400, yfx, [*, /, div] ).</strong></p>

<p><strong>:- op( 300, xfx, mod).</strong></p>
<script language="JavaScript">line();</script>


<p align="center"><small><strong>Рис. 3. 8.</strong>&nbsp; Множество
предопределенных операторов</a><a name="tn188">.</small></p>

<p><span id="t188">Для удобства некоторые операторы в
пролог-системах определены заранее</span>, чтобы
ими можно было пользоваться сразу, без
какого-либо определения их в программе. Набор
таких операторов и их приоритеты зависят от
реализации. Мы будем предполагать, что множество
этих &quot;стандартных&quot; операторов ведет себя
так, как если бы оно было определено с помощью
предложений, приведенных на рис. 3.8. Как видно из
того же рисунка, несколько операторов могут быть
определены в одном предложении, если только они
все имеют одинаковый приоритет и тип. В этом
случае имена операторов записываются в виде
списка. Использование операторов может
значительно повысить наглядность,
&quot;читабельность&quot; программы. Для примера
предположим, что мы пишем программу для
обработки булевских выражений. В такой программе
мы, возможно, захотим записать утверждение одной
из теорем де Моргана, которое в математических
обозначениях записывается так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~ (А &amp; В)&nbsp; &lt;<strong>===</strong>&gt;
&nbsp; ~А&nbsp; v&nbsp; ~В</p>

<p>Приведем один из способов записи этого
утверждения в виде прологовского предложения:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>эквивалентно( not( и(
А, В)), или( not( A, not( B))).</strong></p>

<p>Однако хорошим стилем программирования было бы
попытаться сохранить по возможности больше
сходства между видом записи исходной задачи и
видом, используемом в программе ее решения. В
нашем примере этого можно достичь почти в полной
мере, применив операторы. Подходящее множество
операторов для наших целей можно определить так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>:- ор( 800, xfx, &lt;===&gt;).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :- ор( 700, xfy, v).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :- ор( 600, хfу, &amp;).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :- ор( 500, fy, ~).</strong></p>

<p>Теперь правило де Моргана можно записать в виде
следующего факта:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>~(А &amp; В)&nbsp; &lt;===&gt;
&nbsp; ~А&nbsp; v&nbsp; ~В.</strong></p>

<p>В соответствии с нашими определениями
операторов этот терм понимается так, как это
показано на рис. 3.9.</p>

<p align="center"><img src="pic/fig3_9.gif" width="337" height="254"
alt="fig3_9.gif (1184 bytes)"></p>

<p align="center"><small><strong>Рис. 3. 9.</strong>&nbsp; Интерпретация
терма <strong>~(А&nbsp; &amp;&nbsp; В)&nbsp; &lt;===&gt; ~A&nbsp; v&nbsp; ~В</strong></small></p>

<p>Подытожим: 

<ul>
  <li>Наглядность программы часто можно улучшить,
    использовав операторную нотацию. Операторы
    бывают инфиксные, префиксные и постфиксные.</li>
  <li>В принципе, с оператором не связываются никакие
    действия над данными, за исключением особых
    случаев. Определение оператора не содержит
    описания каких-либо действий, оно лишь вводит
    новый способ записи. Операторы, как и функторы,
    лишь связывают компоненты в единую структуру.</li>
  <li>Программист может вводить свои собственные
    операторы. Каждый оператор определяется своим
    именем, приоритетом и типом.</li>
  <li>Номер приоритета - это целое число из некоторого
    диапазона, скажем, между 1 и 1200. Оператор с самым
    больший номером приоритета соответствует
    главному функтору выражения, в котором этот
    оператор встретился. Операторы с меньшими
    номерами приоритетов связывают свои аргументы
    сильнее других операторов.</li>
  <li>Тип оператора зависит от двух условий:
    &nbsp;&nbsp;&nbsp; (1)&nbsp;&nbsp;&nbsp; его расположения
    относительно своих аргументов,&nbsp;&nbsp;&nbsp; (2)
    &nbsp;&nbsp;&nbsp; приоритета его аргументов по
    сравнению с его собственным. В спецификаторах,
    таких, как <strong>xfy</strong>,&nbsp; <strong>х</strong> &nbsp;
    обозначает аргумент, чей номер приоритета строго
    меньше номера приоритета оператора;&nbsp; <strong>у</strong>
    &nbsp; - аргумент с номером приоритета, меньшим или
    равным номеру приоритета оператора.</li>
</ul>

<h4>Упражнения</h4>

<p><strong>3. 12.</strong>&nbsp;&nbsp;&nbsp; Если принять такие
определения</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>:- ор( 300, xfy, играет_в).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :- ор( 200, xfy, и).</strong></p>

<p>то два следующих терма представляют собой
синтаксически правильные объекты:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Tepмl = джимми
играет_в футбол и сквош<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Терм1 = сьюзан играет_в
теннис и баскетбол и волейбол</strong></p>

<p>Как эти термы интерпретируются
пролог-системой? Каковы их главные функторы и
какова их структура?</p>
</a>

<p><a href="javascript:fa('3_12')">Посмотреть ответ</a></p>

<p><strong>3. 13.</strong>&nbsp;&nbsp;&nbsp; Предложите подходящее
определение операторов (&quot;работает&quot;, &quot;в&quot;,
&quot;нашем&quot;), чтобы можно было писать
предложения типа:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>диана работает
секретарем в нашем отделе.</strong></p>

<p>а затем спрашивать:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?- Кто работает
секретарем в нашем отделе.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Кто = диана</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?- диана работает
Кем.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Кем = секретарем в нашем
отдела</strong></p>

<p><a href="javascript:fa('3_13')">Посмотреть ответ</a></p>

<p><strong>3. 14.</strong>&nbsp;&nbsp;&nbsp; Рассмотрим программу:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>t( 0+1, 1+0).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t( X+0+1, X+1+0).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t( X+1+1, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t( X+1, X1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t( X1+1, Z).</strong></p>

<p>Как данная программа будет отвечать на ниже
перечисленные вопросы, если '+' &quot;- это (как
обычно) инфиксный оператор типа <strong>yfx</strong>?</p>

<p>(a)&nbsp;&nbsp;&nbsp; <strong>?- t( 0+1, А).</strong></p>

<p>(b)&nbsp;&nbsp;&nbsp; <strong>?- t( 0+1+1, В).</strong></p>

<p>(с)&nbsp;&nbsp;&nbsp; <strong>?- t( 1+0+1+1+1, С).</strong></p>

<p>(d)&nbsp;&nbsp;&nbsp; <strong>?- t( D, 1+1+1+0).</strong></p>

<p><a href="javascript:fa('3_14')">Посмотреть ответ</a></p>

<p><strong>3. 15.</strong>&nbsp;&nbsp;&nbsp; В предыдущем разделе
отношения между списка ми мы записывали так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>принадлежит(
Элемент, Список),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; конк( Список1, Список2,
Список3),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; удалить( Элемент, Список,
НовыйСписок),&nbsp;&nbsp; . . .</strong></p>

<p>Предположим, что более предпочтительной для
нас является следующая форма записи: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Элемент входит_в
Список,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; конкатенация_списков
Список1 и Список2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; дает
Список3,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; удаление_элемента
Элемент из_списка Список<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; дает
НовыйСписок, ...</strong></p>

<p>Определите операторы &quot;входит_в&quot;,
&quot;конкатенация_списков&quot;, &quot;и&quot; и т.д. таким
образом, чтобы обеспечить эту возможность.
Переопределите также и соответствующие
процедуры.</p>

<p><a href="javascript:fa('3_15')">Посмотреть ответ</a></p>

<hr>

<p align="center"><a href="ch3_2.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch3_4.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 3. Пункт 1</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch2_7.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch3_2.htm">Вперёд</a></p>

<hr>

<h3 align="center">Глава 3</h3>

<h3 align="center">СПИСКИ, ОПЕРАТОРЫ, <a name="tn282">АРИФМЕТИКА</h3>

<p>В этой главе мы будем изучать специальные
способы представления списков. <span id="t282">Список</span>
- один из самых простых и полезных типов структур.
Мы рассмотрим также некоторые программы для
выполнения типовых операций над списками и,
кроме того, покажем, как можно просто записывать
арифметические выражения и операторы, что во
многих случаях позволит улучшить
&quot;читабельность&quot; программ. Базовый Пролог
(глава 2), расширенный этими тремя добавлениями,
станет удобной основой для составления
интересных программ. </p>
</a><a name="p3_1"><script language="JavaScript">double_line();</script>
</a>

<h4>3. 1.&nbsp;&nbsp;&nbsp; Представление списков</h4>

<p><em>Список</em> - это простая структура данных,
широко используемая в нечисловом
программировании. Список - это
последовательность, составленная из
произвольного числа элементов, например <strong>энн,
теннис, том, лыжи</strong>. На Прологе это
записывается так:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ энн, теннис,
том, лыжи ]</strong></p>

<p>Однако таково лишь внешнее представление
списков. Как мы уже видели в гл. 2, все структурные
объекты Пролога - это деревья. Списки не являются
исключением из этого правила.</p>

<p>Каким образом можно представить список в виде
стандартного прологовского объекта? Мы должны
рассмотреть два случая: пустой список и не пустой
список. В первом случае список записывается как
атом&nbsp; [ ].&nbsp; Во втором случае список следует
рассматривать как структуру состоящую из двух
частей<a name="tn88">:</p>

<p>(1)&nbsp;&nbsp;&nbsp; первый элемент, называемый <span id="t88"><em>головой</em>
списка</span></a><a name="tn298">;</p>

<p>(2)&nbsp;&nbsp;&nbsp; остальная часть списка, называемая <em><span
id="t298">хвостом</span></em>.</p>

<p>Например, для списка</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ энн, теннис,
том, лыжи ]</strong></p>

<p><strong>энн</strong> - это голова, а хвостом является
список</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ теннис, том,
лыжи ]</strong></p>

<p>В общем случае, головой может быть что угодно
(любой прологовский объект, например, дерево или
переменная); хвост же должен быть списком. Голова
соединяется с хвостом при помощи специального
функтора. Выбор этого функтора зависит от
конкретной реализации Пролога; мы будем считать,
что это точка:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>.( Голова,
Хвост)</strong></p>

<p>Поскольку <strong>Хвост</strong> - это список, он либо
пуст, либо имеет свои собственную голову и хвост.
Таким образом, выбранного способа представления
списков достаточно для представления списков
любой длины. Наш список представляется следующим
образом:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>.( энн, .(
теннис, .( том, .( лыжи, [ ] ) ) ) )</strong></p>

<p>На рис. 3.1 изображена соответствующая
древовидная структура. Заметим, что показанный
выше пример содержит пустой список [ ]. Дело в том,
что самый последний хвост является
одноэлементным списком:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ лыжи ]</strong></p>

<p>Хвост этого списка пуст</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ лыжи ] = .(
лыжи, [ ] )</strong></p>

<p>Рассмотренный пример показывает, как общий
принцип структуризации объектов данных можно
применить к спискам любой длины. Из нашего
примера также видно, что такой примитивный
способ представления в случае большой глубины
вложенности подэлементов в хвостовой части
списка может привести к довольно запутанным
выражениям. Вот почему в Прологе
предусматривается более лаконичный способ
изображения списков, при котором они
записываются как последовательности элементов,
заключенные в квадратные скобки. Программист
может использовать оба способа, но представление
с квадратными скобками, конечно, в большинстве
случаев пользуется предпочтением. Мы, однако,
всегда будем помнить, что это всего лишь
косметическое улучшение и что во внутреннем
представлении наши списки выглядят как деревья.
При выводе же они автоматически преобразуются в
более лаконичную форму представления. Так,
например, возможен следующий диалог:</p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?-&nbsp; Список1 = [а, b,
с],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Список2 =
(a,&nbsp; .(b,&nbsp; .(c,[ ]) ) ).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Список1 = [а, b, с]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Список2 = [а, b, с]</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?-&nbsp; Увлечения1 = .(
теннис, .(музыка, [ ] ) ),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Увлечения2
= [лыжи, еда],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = [энн,
Увлечения1, том, Увлечения2].</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Увлечения1 = [теннис,
музыка]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Увлечения2 = [лыжи, еда]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = [энн, [теннис, музыка],
том, [лыжи, еда]]</strong></p>

<p align="center"><img src="pic/fig3_1.gif" width="340" height="275"
alt="fig3_1.gif (1154 bytes)"></p>

<p align="center"><small><strong>Рис. 3. 1.</strong>&nbsp; Представление
списка <strong>[энн, теннис, том, лыжи]</strong> в виде
дерева.</small></p>

<p>Приведенный пример также напоминает вам о том,
что элементами списка могут быть любые объекты, в
частности тоже списки.</p>

<p>На практике часто бывает удобным трактовать
хвост списка как самостоятельный объект.
Например, пусть</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>L = [а, b, с]</strong></p>

<p>Тогда можно написать:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>Хвост = [b, с] и
L = .(а, Хвост)</strong></p>

<p>Для того, чтобы выразить это при помощи
квадратных скобок, в Прологе предусмотрено еще
одно расширение нотации для представления
списка, а именно вертикальная черта, отделяющая
голову от хвоста:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>L = [а | Хвост]</strong></p>

<p>На самом деле вертикальная черта имеет более
общий смысл: мы можем перечислить любое
количество элементов списка, затем поставить
символ &quot; | &quot;, а после этого - список остальных
элементов. Так, только что рассмотренный пример
можно представить следующими различными
способами:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>[а, b, с] = [а | [b,
с]] = [a, b | [c]] = [a, b, c | [ ]]</strong></p>

<p>Подытожим: 

<ul>
  <li>Список - это структура данных, которая либо
    пуста, либо состоит из двух частей: <em>головы</em> и <em>хвоста</em>.
    Хвост в свою очередь сам является списком.</li>
  <li>Список рассматривается в Прологе как
    специальный частный случай двоичного дерева. Для
    повышения наглядности программ в Прологе
    предусматриваются специальные средства для
    списковой нотации, позволяющие представлять
    списки в виде<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ Элемент1, Элемент2, ...
    ]</strong><br>
    <br>
    или<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ Голова | Хвост ]</strong><br>
    <br>
    или<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>[ Элемент1, Элемент2, ...
    | Остальные]</strong></li>
</ul>

<hr>
</a>

<p align="center"><a href="ch2_7.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch3_2.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 2. Пункт 6</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch2_5.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch2_7.htm">Вперёд</a></p>
<script language="JavaScript">double_line();</script>


<h4>2. 6.&nbsp;&nbsp;&nbsp; Порядок предложений и целей</h4>
<a name="p2_6_1">

<hr>
</a>

<h4>2. 6. 1.&nbsp;&nbsp;&nbsp; Опасность бесконечного цикла</h4>

<p>Рассмотрим следующее предложение:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>р&nbsp;&nbsp;
:-&nbsp;&nbsp; р.</strong></p>

<p>В нем говорится: &quot;р истинно, если р
истинно&quot;. С точки зрения декларативного смысла
это совершенно корректно, однако в процедурном
смысле оно бесполезно. Более того, для
пролог-системы такое предложение может породить
серьезную проблему. Рассмотрим вопрос:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; р.</strong></p>

<p>При использовании вышеприведенного
предложения цель р будет заменена на ту же самую
цель р; она в свою очередь будет заменена снова на
р и т.д. В этом случае система войдет в
бесконечный цикл, не замечая, что никакого
продвижения в вычислениях не происходит.</p>

<p>Данный пример демонстрирует простой способ
ввести пролог-систему в бесконечный цикл. Однако
подобное зацикливание могло встретиться и в
некоторых наших предыдущих программах, если бы
мы изменили порядок предложений, или же порядок
целей в них. Будет полезно рассмотреть несколько
примеров.</p>

<p>В программе об обезьяне и банане предложения,
касающиеся отношения <strong>ход</strong>, были
упорядочены следующим образом: схватить,
залезть, подвинуть, перейти (возможно, для
полноты следует добавить еще &quot;слезть&quot;). В
этих предложениях говорится, что можно схватить,
можно залезть и т.д. В соответствии с процедурной
семантикой Пролога порядок предложений
указывает на то, что обезьяна предпочитает
схватывание залезанию, залезание - передвиганию
и т.д. Такой порядок предпочтений на самом деле
помогает обезьяне решить задачу. Но что могло
случиться. если бы этот порядок был другим?
Предположим, что предложение с &quot;перейти&quot;
оказалось бы первым. Процесс вычисления нашей
исходной цели из предыдущего раздела</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-
можетзавладеть( состояние( удвери, наполу, уокна,
неимеет) ).</strong></p>

<p>протекал бы на этот раз так. Первые четыре
списка целей (с соответствующим образом
переименованными переменными) остались бы
такими же, как и раньше:</p>

<p>(1)&nbsp;&nbsp;&nbsp; <strong>можетзавладеть( состояние(
удвери, наполу, уокна, неимеет) ).</strong></p>

<p>Применение второго предложения из <strong>можетзавладеть</strong>
(&quot;может2&quot;) породило бы</p>

<p>(2)&nbsp;&nbsp;&nbsp; <strong>ход( состояние( удвери, наполу,
уокна, неимеет), М', S2'),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; можетзавладеть(
S2')</strong></p>

<p>С помощью хода <strong>перейти( уокна, Р2')</strong>
получилось бы</p>

<p>(3)&nbsp;&nbsp;&nbsp; <strong>можетзавладеть( состояние( Р2',
наполу, уокна, неимеет) )</strong></p>

<p>Повторное использование предложения
&quot;может2&quot; превратило бы список целей в</p>

<p>(4)&nbsp;&nbsp;&nbsp; <strong>ход( состояние(Р2', наполу,
уокна, неимеет), М'', S2''),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; можетзавладеть(
S2&quot;)</strong></p>

<p>С этого момента начались бы отличия. Первым
предложением, голова которого сопоставима с
первой целью из этого списка, было бы теперь
&quot;перейти&quot; (а не &quot;залезть&quot;, как раньше).
Конкретизация стала бы следующей:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>S2&quot; =
состояние( Р2&quot;, наполу, уокна, неимеет).</strong></p>

<p>Поэтому список целей стал бы таким:</p>

<p>(5)&nbsp;&nbsp;&nbsp; <strong>можетзавладеть( состояние( Р2'',
наполу, уокна, неимеет) )</strong></p>

<p>Применение предложения &quot;может2&quot; дало бы</p>

<p>(6)&nbsp;&nbsp;&nbsp; <strong>ход( cocтояниe( P2&quot;, наполу, yoкнa,
неимeeт), M&quot; ', S2'' '),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; можетзавладеть(
S2&quot; ')</strong></p>

<p>Снова первый было бы попробовано &quot;перейти&quot;
и получилось бы</p>

<p>(7)&nbsp;&nbsp;&nbsp; <strong>можетзавладеть( состояние(
Р2&quot; ', наполу, уокна, неимеет) )</strong></p>

<p>Сравним теперь цели&nbsp; (3),&nbsp; (5)&nbsp; и&nbsp; (7). &nbsp;
Они похожи и отличаются лишь одной переменной,
которая по очереди имела имена&nbsp; Р', &nbsp; Р''&nbsp;
и&nbsp; P&quot; '.&nbsp; Как мы знаем, успешность цели не
зависит от конкретных имен переменных в ней. Это
означает, что, начиная со списка целей (3), процесс
вычислений никуда не продвинулся. Фактически мы
замечаем, что по очереди многократно
используются одни и те же два предложения:
&quot;может2&quot; и &quot;перейти&quot;. Обезьяна
перемещается, даже не пытаясь воспользоваться
ящиком. Поскольку продвижения нет, такая
ситуация продолжалась бы (теоретически)
бесконечно: пролог-система не сумела бы осознать,
что работать в этой направлении нет смысла.</p>

<p>Данный пример показывает, как пролог-система
может пытаться решить задачу таким способом, при
котором решение никогда не будет достигнуто,
хотя оно существует. Такая ситуация не является
редкостью при программировании на Прологе. Да и
при программировании на других языках
бесконечные циклы не такая уж редкость. Что <em>действительно</em>
необычно при сравнении Пролога с другими
языками, так это то, что декларативная семантика
пролог-программы может быть правильной, но в то
же самое время ее процедурная семантика может
быть ошибочной в том смысле, что с помощью такой
программы нельзя получить правильный ответ на
вопрос. В таких случаях система не способна
достичь цели потому, что она пытается добраться
до ответа, но выбирает при этом неверный путь.</p>

<p>Теперь уместно спросить: &quot;Не можем ли мы
внести какое-либо более существенное изменение в
нашу программу, так чтобы полностью исключить
опасность зацикливания? Или же нам всегда
придется рассчитывать на удачный порядок
предложений и целей?&quot; Как оказывается,
программы, в особенности большие, были бы
чересчур ненадежными, если бы можно было
рассчитывать лишь на некоторый удачный порядок.
Существует несколько других методов,
позволяющих избежать зацикливания и являющихся
более общими и надежными, чем сам по себе метод
упорядочивания. Такие методы будут
систематически использоваться дальше в книге, в
особенности в тех главах, в которых пойдет речь о
нахождении путей (в графах), о решения
интеллектуальных задач и о переборе.</p>
<a name="p2_6_2">

<hr>
</a>

<h4>2. 6. 2.&nbsp;&nbsp;&nbsp; Варианты программы, полученые
путем переупорядочивания предложений и целей</h4>

<p>Уже в примерах программ гл. 1 существовала
скрытая опасность зацикливания. Определение
отношения <strong>предок</strong> в этой главе было
таким:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>предок( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель(
X, Z).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; предок( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель(
X, Y),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; предок(
Y, Z).</strong></p>

<p>Проанализируем некоторые варианты этой
программы. Ясно, что все варианты будут иметь
одинаковую декларативную семантику, но разные
процедурные семантики.</p>

<p>В соответствии с декларативной семантикой
Пролога мы можем, не меняя декларативного смысла,
изменить</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; порядок предложений в
программе и</p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; порядок целей в телах
предложений.</p>

<p>Процедура <strong>предок</strong> состоит из двух
предложений, и одно из них содержит в своем теле
две цели. Возможны, поэтому, четыре варианта
данной программы, все с одинаковым декларативным
смыслом. Эти четыре варианта можно получить, если</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; поменять местами оба
предложения и<br>
(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; поменять местами цели в
каждом из этих двух последовательностей
предложений.</p>

<p>Соответствующие процедуры, названные <strong>пред1</strong>,
<strong>пред2</strong>, <strong>пред3</strong> и <strong>пред4</strong>,
показаны на рис. 2.16.</p>

<p>Есть существенная разница в поведении этих
четырех декларативно эквивалентных процедур.
Чтобы это продемонстрировать, будем считать,
отношение <strong>родитель</strong> определенным так,
как показано на рис. 1.1 гл. 1. и посмотрим, что
произойдет, если мы спросим, является ли Том
предком Пат, используя все четыре варианта
отношения <strong>предок</strong>:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; пред1(
том, пат).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; да</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?-&nbsp; пред2( том, пат).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; да</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?-&nbsp; пред3( том, пат).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; да</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?-&nbsp; пред4( том, пат).</strong></p>
<script language="JavaScript">line();</script>


<p><small>%&nbsp; Четыре версии программы предок<br>
%&nbsp; Исходная версия</small></p>

<p><strong>пред1( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X, Z).</strong></p>

<p><strong>пред1( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X, Y),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; пред1( Y, Z).</strong></p>

<p><small>%&nbsp; Вариант&nbsp; а:&nbsp; изменение порядка
предложений в исходной версии</small></p>

<p><strong>пред2( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X, Y),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; пред2( Y, Z).</strong></p>

<p><strong>пред2( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X, Z).</strong></p>

<p><small>%&nbsp; Вариант&nbsp; b:&nbsp; изменение порядка
целей во втором предложении<br>
%&nbsp; исходной версии</small></p>

<p><strong>пред3( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X, Z).</strong></p>

<p><strong>пред3( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; пред3( X, Y),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( Y, Z).</strong></p>

<p><small>%&nbsp; Вариант&nbsp; с:&nbsp; изменение порядка
предложений и целей в исходной<br>
%&nbsp; версии</small></p>

<p><strong>пред4( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; пред4( X, Y),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( Y, Z).</strong></p>

<p><strong>пред4( X, Z):-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X, Z).</strong></p>
<script language="JavaScript">line();</script>


<p align="center"><small><strong>Рис. 2. 16.</strong>&nbsp; Четыре версии
программы <strong>предок</strong>.</small></p>

<p>В последнем случае пролог-система не сможет
найти ответа. И выведет на терминал сообщение:
&quot;Не хватает памяти&quot;.</p>

<p>На рис. 1.11 гл. 1 были показаны все шаги
вычислений по <strong>пред1</strong> (в главе 1 она
называлась <strong>предок</strong>), предпринятые для
ответа на этот вопрос. На рис 2.17 показаны
соответствующие вычисления по <strong>пред2</strong>, <strong>пред3</strong>
и <strong>пред4</strong>. На рис. 2.17 (с) ясно видно, что
работа <strong>пред4</strong> - бесперспективна, а рис.
2.17(а) показывает, что <strong>пред2</strong> довольно
неэффективна по сравнению с <strong>пред1</strong>: <strong>пред2</strong>
производит значительно больший перебор и делает
больше возвратов по фамильному дереву.</p>

<p>Такое сравнение должно напомнить нам об общем
практическом правиле при решении задач: обычно
бывает полезным прежде всего попробовать самое
простое соображение. В нашем случае все версии
отношения <strong>предок</strong> основаны на двух
соображениях: 

<ul>
  <li>более простое - нужно проверить, не
    удовлетворяют ли два аргумента отношения <strong>предок</strong>
    отношению <strong>родитель</strong>;</li>
  <li>более сложное - найти кого-либо &quot;между&quot;
    этими двумя людьми (кого-либо, кто связан с ними
    отношениями <strong>родитель</strong> и <strong>предок</strong>).</li>
</ul>

<p>Из всех четырех вариантов отношения <strong>предок</strong>,
<strong>пред1</strong> использует наиболее простое
соображение в первую очередь. В
противоположность этому <strong>пред4</strong> всегда
сначала пробует использовать самое сложное. <strong>Пред2</strong>
и <strong>пред3</strong> находятся между этими двумя
крайностями. Даже без детального изучения
процессов вычислений ясно, что <strong>пред1</strong>
следует предпочесть просто на основании правила
&quot;самое простое пробуй в первую очередь&quot;.</p>

<p>Наши четыре варианта процедуры <strong>предок</strong>
можно далее сравнить, рассмотрев вопрос: &quot;На
какие типы вопросов может отвечать тот или иной
конкретный вариант и на какие не может?&quot;
Оказывается, <strong>пред1</strong> и <strong>пред2</strong> оба
способны найти ответ на любой вид вопроса
относительно предков; <strong>пред4</strong> никогда не
находит ответа, а <strong>пред3</strong> иногда может
найти, иногда нет. Вот пример вопроса, на который <strong>пред4</strong>
ответить не может:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; пред3(
лиз, джим).</strong></p>

<p>Такой вопрос тоже вводит систему в бесконечную
рекурсию. Следовательно и <strong>пред3</strong> нельзя
признать верным с точки зрения процедурного
смысла.</p>

<p align="center"><img src="pic/fig2_17.gif" width="456" height="1558"
alt="fig2_17.gif (14174 bytes)"></p>

<p align="center"><small><strong>Рис. 2. 17.</strong>&nbsp; Поведение трех
вариантов формулировки отношения</small><br>
<small><strong>предок</strong> при ответе на вопрос,
является ли Том предком Пат?</small></p>
<a name="p2_6_3">

<hr>
</a>

<h4>2. 6. 3.&nbsp;&nbsp;&nbsp; Сочетание декларативного и
процедурного подходов</h4>

<p>В предыдущем разделе было показано, что порядок
целей и предложений имеет существенное значение.
Более того, существуют программы, которые верны в
декларативном смысле, но на практике не работают.
Такое противоречие между декларативным и
процедурным смыслами может вызвать
недовольство. Кто-нибудь спросит: &quot;А почему
вообще не забыть о декларативном смысле?&quot;
Такое пожелание становится особенно сильным,
когда рассматриваются предложения типа:</p>

<p><strong>&nbsp;&nbsp; </strong>&nbsp;&nbsp;&nbsp;&nbsp; <strong>предок( X, Z) :-
предок( X, Z).</strong></p>

<p>Это предложение верно в декларативном смысле,
но совершенно бесполезно в качестве рабочей
программы.</p>

<p>Причина, по которой не следует забывать о
декларативном смысле, кроется в том, что
прогресс, достигнутый в технологии
программирования, получен на пути продвижения от
учета всех процедурных деталей к концентрации
внимания на декларативных аспектах, которые
обычно легче формулировать и понимать. Сама
система, а не программист, должна нести бремя
заботы о процедурных деталях. В этом Пролог
оказывает некоторую помощь, хотя, как мы видели в
данном разделе, помощь лишь частичную: иногда он
правильно прорабатывает эти процедурные детали,
иногда - нет. Многие придерживаются мнения, что
лучше иметь хоть какую-то декларативную
семантику, чем никакой (отсутствие декларативной
семантики характерно для многих других языков
программирования). Практическим следствием
такого взгляда является тот факт, что часто
довольно легко получить работающую программу,
имея программу декларативно корректную. Поэтому
практичным следует признать такой подход:
сосредоточиться на декларативных аспектах
задачи, затем пропустить на машине полученную
программу и, если она окажется процедурно
неправильной, попытаться изменить порядок
следования предложений и целей.</p>

<hr>

<p align="center"><a href="ch2_5.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch2_7.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 8. Пункт 2</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch8_1.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch8_3.htm">Вперёд</a></p>
<script language="JavaScript">double_line();</script>


<h4>8. 2.&nbsp;&nbsp;&nbsp; Как представлять себе программы
на Прологе</h4>

<p>Одной из характерных особенностей Пролога
является то, что в нем допускается как
процедурный, так и декларативный стиль мышления
при составлении программы. Эти два подхода
детально обсуждались в гл. 2 и затем многократно
иллюстрировались на примерах. Какой из этих
подходов окажется более эффективным и
практичным, зависит от конкретной задачи. Обычно
построение декларативного решения задачи
требует меньших усилий, но может привести к
неэффективной программе. В процессе построения
решения мы должны сводить задачу к одной или
нескольким более легким подзадачам. Возникает
важный вопрос: как находить эти подзадачи?
Существует несколько общих принципов, которые
часто применяются при программировании на
Прологе. Они будут обсуждаться в следующих
разделах.</p>
<a name="p8_2_1">

<hr>
</a>

<h4>8. 2. 1.&nbsp;&nbsp;&nbsp; Использование рекурсии</h4>

<p>Этот принцип состоит в том, чтобы разбить
задачу на случаи, относящиеся к двум группам:</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; тривиальные, или
&quot;граничные&quot; случаи;<br>
(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;общие&quot; случаи, в
которых решение получается из решений для (более
простых) вариантов самой исходной задачи.</p>

<p>Этот метод мы использовали в Прологе постоянно.
Рассмотрим еще один пример: обработка списка
элементов, при которой каждый элемент
преобразуется по одному и тому же правилу. Пусть
это будет процедура</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>преобрспис( Спис, F,
НовСпиc)</strong></p>

<p>где <strong>Спис</strong> - исходный список, <strong>F</strong> -
правило преобразования (бинарное отношение), а <strong>НовСпиc</strong>
- список всех преобразованных элементов. Задачу
преобразования списка <strong>Спис</strong> можно
разбить на два случая:</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Граничный случай: <strong>Спис
= [ ]</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Если <strong>Спис
= [ ]</strong>, то <strong>НовСпиc = [ ]</strong>, независимо от <strong>F</strong></p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Общий случай: <strong>Спис
= [X | Хвост]</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Чтобы
преобразовать список вида <strong>[X | Хвост]</strong>,
необходимо:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
преобразовать список <strong>Хвост</strong>; результат - <strong>НовХвост</strong>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
преобразовать элемент <strong>Х</strong> по правилу <strong>F</strong>;
результат - <strong>НовХ</strong>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
результат преобразования всего списка - <strong>[НовХ
| НовХвост]</strong>.</p>

<p>Тот же алгоритм, изложенный на Прологе:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>преобрспис( [ ], _, [ ]).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; преобрспис( [Х |
Хвост], F, [НовХ | НовХвост] :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
G =.. [F, X, НовХ],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
саll( G),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
пpeoбpcпиc( Хвост, F, НовХвост).</strong></p>

<p>Одна из причин того, что рекурсия так
естественна для определения отношений на
Прологе, состоит в том, что объекты данных часто
сами имеют рекурсивную структуру. К таким
объектам относятся списки и деревья. Список либо
пуст (граничный случай), либо имеет голову и
хвост, который сам является списком (общий
случай). Двоичное дерево либо пусто (граничный
случай), либо у него есть корень и два поддерева,
которые сами являются двоичными деревьями (общий
случай). Поэтому для обработки всего непустого
дерева необходимо сначала что-то сделать с его
корнем, а затем обработать поддеревья<a name="tn176">.</p>
</a><a name="p8_2_2">

<hr>
</a>

<h4>8. 2. 2.&nbsp;&nbsp;&nbsp; <span id="t176">Обобщение</span></h4>

<p>Часто бывает полезно обобщить исходную задачу
таким образом, чтобы полученная более общая
задача допускала рекурсивную формулировку.
Исходная задача решается, тогда как частный
случай ее более общего варианта. Обобщение
отношения обычно требует введения одного или
более дополнительных аргументов. Главная
проблема состоит в отыскании подходящего
обобщения, что может потребовать более
тщательного изучения задачи. В качестве примера
рассмотрим еще раз задачу о восьми ферзях.
Исходная задача состояла в следующем: разместить
на доске восемь ферзей так, чтобы обеспечить
отсутствие взаимных нападений. Соответствующее
отношение назовем</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>восемьферзей( Поз)</strong></p>

<p>Оно выполняется (истинно), если <strong>Поз</strong> -
представленная тем или иным способом позиция,
удовлетворяющая условию задачи. Можно
предложить следующую полезную идею: обобщить
задачу, перейдя от 8 ферзей к произвольному
количеству - N. Количество ферзей станет
дополнительным аргументом:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>n_ферзей( Поз, N)</strong></p>

<p>Преимущество такого обобщения состоит в том,
что отношение <strong>n_ферзей</strong> допускает
непосредственную рекурсивную формулировку:</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Граничный случай: N = 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Разместить 0 ферзей - тривиальная задача.</p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Общий случай: N &gt; 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Для
&quot;безопасного&quot; размещения N ферзей
необходимо:</p>

<blockquote>
  <ul>
    <li>получить требуемое размещение для (N - 1) ферзей и</li>
    <li>добавить оставшегося ферзя так, чтобы он не бил
      ни одного из уже поставленных ферзей.</li>
  </ul>
</blockquote>

<p>Как только мы научимся решать более общую
задачу, решить исходную уже не составит труда:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>восемьферзей( Поз) :-
n_ферзей( Поз, 8)</strong></p>
<a name="p8_2_3">

<hr>
</a>

<h4>8. 2. 3.&nbsp;&nbsp;&nbsp; Использование рисунков</h4>

<p>В поиске идей для решения задачи часто бывает
полезным обратиться к ее графическому
представлению. Рисунок может помочь выявить в
задаче некоторые существенные отношения. После
этого останется только описать на языке
программирования то, что мы <em>видим</em> на
рисунке.</p>

<p>Использование графического представления при
решении задач полезно всегда, однако похоже, что
в Прологе оно работает особенно хорошо.
Происходит это по следующим причинам:</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пролог особенно
хорошо приспособлен для задач, в которых
фигурируют объекты и отношения между ними. Часто
такие задачи естественно иллюстрировать
графами, в которых узлы соответствуют объектам, а
дуги - отношениям.</p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Естественным
наглядным изображением структурных объектов
Пролога являются деревья.</p>

<p>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Декларативный
характер пролог-программ облегчает перевод
графического представления на Пролог. В
принципе, порядок описания &quot;картинки&quot; не
играет роли, мы просто помещаем в программу то,
что видим, в произвольном порядке. (Возможно, что
из практических соображений этот порядок
впоследствии придется подправить с целью
повысить эффективность программы.)</p>

<hr>

<p align="center"><a href="ch8_1.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch8_3.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

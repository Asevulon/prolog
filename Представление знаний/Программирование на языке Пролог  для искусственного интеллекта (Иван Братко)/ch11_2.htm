<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 11. Пункт 2</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch11_1.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch11_3.htm">Вперёд</a></p>
<a name="tn211"><script language="JavaScript">double_line();</script>


<h4>11. 2.&nbsp;&nbsp;&nbsp; <span id="t211">Стратегия поиска в
глубину</span></h4>

<p>Существует много различных подходов к проблеме
поиска решающего пути для задач,
сформулированных в терминах пространства
состояний. Основные две стратегии поиска - это
поиск <em>в глубину</em> и <em>поиск в ширину</em>. В
настоящем разделе мы реализуем первую из них.</p>

<p>Мы начнем разработку алгоритма и его вариантов
со следующей простой идеи:</p>
<script language="JavaScript">line();</script>


<p>Для того, чтобы найти решающий путь <strong>Реш</strong>
из заданной вершины <strong>В</strong> в некоторую
целевую вершину, необходимо: 

<ul>
  <li>если <strong>В</strong> - это целевая вершина, то
    положить <strong>Реш = [В]</strong>, или</li>
  <li>если для исходной вершины <strong>В</strong> существует
    вершина-преемник <strong>В1</strong>, такая, что можно
    провести путь <strong>Реш1</strong> из <strong>В1</strong> в
    целевую вершину, то положить <strong>Реш = [В | Peш1]</strong>.</li>
</ul>
<script language="JavaScript">line();</script>


<p align="center"><img src="pic/fig11_4.gif" width="275" height="214"
alt="fig11_4.gif (1753 bytes)"></p>

<p align="center"><small><strong>Рис. 11. 4.</strong>&nbsp; Пример
простого пространства состояний:&nbsp; <em><strong>а</strong></em>
&nbsp; -&nbsp; стартовая</small><br>
<small>вершина,<em><strong>&nbsp;&nbsp; </strong>f</em> &nbsp;&nbsp; и<em><strong>&nbsp;&nbsp;
</strong>j</em>&nbsp;&nbsp; -&nbsp; целевые вершины. Порядок, в
которой происходит</small><br>
<small>проход по вершинам пространства состояний
при поиске в глубину:</small><br>
<small><em>а</em>, <em>b</em>, <em>d</em>, <em>h</em>, <em>e</em>,<em> i</em>, <em>j</em>.
Найдено решение <strong>[a, b, e, j]</strong>. После возврата</small><br>
<small>обнаружено другое решение: <strong>[а, с, f]</strong>.</small></p>

<p>На Пролог это правило транслируется так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>решить( В, [В] ) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
цель( В).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; решить( В, [В | Реш1] )
:-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
после( В, В1 ),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
решить( В1, Реш1).</strong></p>

<p>Эта программа и есть реализация поиска в
глубину. Мы говорим &quot;в глубину&quot;, имея в виду
тот порядок, в котором рассматриваются
альтернативы в пространстве состояний. Всегда,
когда алгоритму поиска в глубину надлежит
выбрать из нескольких вершин ту, в которую
следует перейти для продолжения поиска, он
предпочитает самую &quot;глубокую&quot; из них. Самая
глубокая вершина - это вершина, расположенная
дальше других от стартовой вершины. На рис. 11.4 мы
видим на примере, в каком порядке алгоритм
проходит по вершинам. Этот порядок в точности
соответствует результату трассировки процесса
вычислений в пролог-системе при ответе на вопрос</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; решить( а, Реш).</strong></p>

<p>Поиск в глубину наиболее адекватен
рекурсивному стилю программирования, принятому
в Прологе. Причина этого состоит в том, что,
обрабатывая цели, пролог-система сама
просматривает альтернативы именно в глубину.</p>

<p>Поиск в глубину прост, его легко
программировать и он в некоторых случаях хорошо
работает. Программа для решения задачи о восьми
ферзях (см. гл. 4) фактически была примером поиска
в глубину. Для того, чтобы можно было применить к
этой задаче описанную выше процедуру <strong>решить</strong>,
необходимо сформулировать задачу в терминах
пространства состояний. Это можно сделать так: 

<ul>
  <li>вершины пространства состояний - позиции, в
    которых поставлено 0 или более ферзей на
    нескольких последовательно расположенных
    горизонтальных линиях доски;</li>
  <li>вершина-преемник данной вершины может быть
    получена из нее после того, как в соответствующей
    позиции на следующую горизонтальную линию доски
    будет поставлен еще один ферзь, причем таким
    образом, чтобы ни один из уже поставленных ферзей
    не оказался под боем;</li>
  <li>стартовая вершина - пустая доска
    (представляется пустым списком);</li>
  <li>целевая вершина - любая позиция с восемью
    ферзями (правило получения вершины-преемника
    гарантирует, что ферзи не бьют друг друга).</li>
</ul>

<p>Позицию на доске будем представлять как список
Y-координат поставленных ферзей. Получаем
программу:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>после( Ферзи, [Ферзь
| Ферзи] ) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
принадлежит( Ферзь, [1, 2, 3, 4, 5, 6, 7, 8] ),</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Поместить ферзя на любую вертикальную линию</small><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>небьет( Ферзь, Ферзи).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; цель( [ _, _, _, _, _, _, _, _ ]
)</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Позиция с восемью ферзями</small></p>

<p>Отношение <strong>небьет</strong> означает, что <strong>Ферзь</strong>
не может поразить ни одного ферзя из списка <strong>Ферзи</strong>.
Эту процедуру можно легко запрограммировать так
же, как это сделано в гл. 4. Ответ на вопрос</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; решить( [ ],
Решение)</strong></p>

<p>будет выглядеть как список позиций с
постепенно увеличивающимся количеством
поставленных ферзей. Список завершается
&quot;безопасной&quot; конфигурацией из восьми
ферзей. Механизм возвратов позволит получить и
другие решения задачи.</p>

<p>Поиск в глубину часто работает хорошо, как в
рассмотренном примере, однако наша простая
процедура <strong>решить</strong> может попасть в
затруднительное положение, причем многими
способами. Случится ли это или нет - зависит от
структуры пространства состояний. Для того,
чтобы затруднить работу процедуры решить в
примере рис. 11.4, достаточно внести в задачу
совсем небольшое изменение: добавить дугу,
ведущую из <em>h</em>&nbsp; в&nbsp; <em>d</em>,&nbsp; чтобы
получился цикл (рис. 11.5). В этом случае поиск будет
выглядеть так: начиная с вершины&nbsp; <em>а</em>, &nbsp;
спускаемся вплоть до&nbsp; <em>h</em>, &nbsp; придерживаясь
самой левой ветви графа. На этот раз, в отличие от
рис. 11.4, у вершины&nbsp; <em>h</em> &nbsp; будет преемник&nbsp; <em>d</em>.&nbsp;
Поэтому произойдет <em>не возврат</em> из&nbsp; <em>h</em>,&nbsp;
а <em>переход</em> к&nbsp; <em>d</em>.&nbsp; Затем мы найдем
преемника вершины &nbsp; <em>d</em>,&nbsp; т.е. вершину&nbsp; <em>h</em>,&nbsp;
и т.д., в результате программа зациклится
между&nbsp; <em>h</em> &nbsp; и&nbsp; <em>d</em>. </p>

<p align="center"><img src="pic/fig11_5.gif" width="272" height="216"
alt="fig11_5.gif (1376 bytes)"></p>

<p align="center"><small><strong>Рис. 11. 5.</strong>&nbsp; Начинаясь в <em>а</em>,
поиск вглубину заканчивается<br>
бесконечным циклом между&nbsp; <em>d</em>&nbsp; и&nbsp; <em>h</em>:
&nbsp; <em>a</em>, <em>b</em>, <em>d</em>, <em>h</em>, <em>d</em>, <em>h</em>, <em>d</em>
... .</small></p>

<p>Очевидное усовершенствование нашей программы
поиска в глубину - добавление к ней механизма
обнаружения циклов. Ни одну из вершин, уже
содержащихся в пути, построенном из стартовой
вершины в текущую вершину, не следует вторично
рассматривать в качестве возможной альтернативы
продолжения поиска. Это правило можно
сформулировать в виде отношения</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>вглубину( Путь,
Верш, Решение)</strong></p>

<p>Как видно из рис. 11.6, <strong>Верш</strong> - это
состояние, из которого необходимо найти путь до
цели; <strong>Путь</strong> - путь (список вершин) между
стартовой вершиной и <strong>Верш</strong>; <strong>Решение</strong>
- <strong>Путь</strong>, продолженный до целевой вершины.</p>

<p align="center"><img src="pic/fig11_6.gif" width="259" height="214"
alt="fig11_6.gif (1223 bytes)"></p>

<p align="center"><small><strong>Рис. 11. 6.</strong>&nbsp; Отношение <strong>вглубину(
Путь, В, Решение)</strong>.</small></p>

<p>Для облегчения программирования вершины в
списках, представляющих пути, будут
расставляться в обратном порядке. Аргумент <strong>Путь</strong>
нужен для того,</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; чтобы не
рассматривать тех преемников вершины <strong>Верш</strong>,
которые уже встречались раньше (обнаружение
циклов);</p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; чтобы облегчить
построение решающего пути <strong>Решение</strong>.
Соответствующая программа поиска в глубину
показана на рис. 11.7.</p>
<script language="JavaScript">line();</script>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>решить( Верш,
Решение) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
вглубину( [ ], Верш, Решение).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вглубину( Путь,
Верш, [Верш | Путь] ) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
цель( Верш).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вглубину( Путь,
Верш, Реш) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
после( Верш, Верш1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
not принадлежит( Верш1, Путь),</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Цикл ?</small><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>вглубину( [Верш | Путь], Верш1, Реш).</strong></p>
<script language="JavaScript">line();</script>


<p align="center"><small><strong>Рис. 11. 7.</strong>&nbsp; Программа
поиска в глубину без зацикливания.</small></p>

<p>Теперь наметим один вариант этой программы.
Аргументы <strong>Путь</strong> и <strong>Верш</strong>
процедуры <strong>вглубину</strong> можно объединить в
один список <strong>[Верш | Путь]</strong>. Тогда, вместо
вершины-кандидата <strong>Верш</strong>, претендующей на
то, что она находится на пути, ведущем к цели, мы
будем иметь <em>путь</em>-кандидат <strong>П = [Верш |
Путь]</strong>, который претендует на то, что его
можно продолжить вплоть до целевой вершины.
Программирование соответствующего предиката</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>вглубину( П,
Решение)</strong></p>

<p>оставим читателю в качестве упражнения.</p>

<p>Наша процедура поиска в глубину, снабженная
механизмом обнаружения циклов, будет успешно
находить решающие пути в пространствах
состояний, подобных показанному на рис. 11.5.
Существуют, однако, такие пространства
состоянии, в которых наша процедура не дойдет до
цели. Дело в том, что многие пространства
состояний бесконечны. В таком пространстве
алгоритм поиска в глубину может &quot;потерять&quot;
цель, двигаясь вдоль бесконечной ветви графа.
Программа будет бесконечно долго обследовать
эту бесконечную область пространства, так и не
приблизившись к цели. Пространство состояний
задачи о восьми ферзях, определенное так, как это
сделано в настоящем разделе, на первый взгляд
содержит ловушку именно такого рода. Но
оказывается, что оно все-таки конечно, поскольку
Y-координаты выбираются из ограниченного
множества, и поэтому на доску можно поставить
&quot;безопасным образом&quot; не более восьми ферзей.</p>
<script language="JavaScript">line();</script>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>вглубину2( Верш,
[Верш], _ ) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
цель( Верш).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вглубину2( Верш,
[Верш | Реш], МаксГлуб) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
МаксГлуб &gt; 0,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
после( Верш, Верш1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Maкс1 is МаксГлуб - 1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
вглубину2( Верш1, Реш, Maкс1).</strong></p>
<script language="JavaScript">line();</script>


<p align="center"><small><strong>Рис. 11. 8.</strong>&nbsp; Программа
поиска в глубину с ограничением по глубине.</small></p>

<p>Для того, чтобы предотвратить бесцельное
блуждание по бесконечным ветвям, мы можем
добавить</a><a name="tn212"> в базовую процедуру поиска в
глубину еще одно усовершенствование, а именно,
ввести <span id="t212">ограничение на глубину поиска</span>.
Процедура поиска в глубину будет тогда иметь
следующие аргументы:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>вглубину2( Верш,
Решение, МаксГлуб)</strong></p>

<p>Не разрешается вести поиск на глубине большей,
чем <strong>МаксГлуб</strong>. Программная реализация
этого ограничения сводится к уменьшению на
единицу величины предела глубины при каждом
рекурсивном обращений к <strong>вглубину2</strong> и к
проверке, что этот предел не стал отрицательным.
В результате получаем программу, показанную на
рис. 11.8.</p>

<h4>Упражнения</h4>

<p><strong>11. 1.</strong>&nbsp;&nbsp;&nbsp; Напишите процедуру
поиска в глубину (с обнаружением циклов)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>вглубину1(
ПутьКандидат, Решение)</strong></p>

<p>отыскивающую решающий путь <strong>Решение</strong>
как продолжение пути <strong>ПутьКандидат</strong>. Оба
пути представляйте списками вершин,
расположенных в обратном порядке так, что
целевая вершина окажется в голове списка <strong>Решение</strong>.</p>
</a>

<p><a href="javascript:fa('11_1')">Посмотреть ответ</a></p>

<p><strong>11. 2.</strong>&nbsp;&nbsp;&nbsp; Напишите процедуру
поиска в глубину, сочетающую в себе обнаружение
циклов с ограничением глубины, используя рис. 11.7
и 11.8.</p>

<p><strong>11. 3.</strong>&nbsp;&nbsp;&nbsp; Проведите эксперимент
по применению программы поиска в глубину к
задаче планирования в &quot;мире кубиков&quot; (рис.
11.1).</p>

<p><strong>11. 4.</strong>&nbsp;&nbsp;&nbsp; Напишите процедуру</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>отобр( Ситуация)</strong></p>

<p>для отображения состояния задачи
&quot;перестановки кубиков&quot;. Пусть <strong>Ситуация</strong>
- это список столбиков, а столбик, в свою очередь, -
список кубиков. Цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>отобр( [ [a], [e, d], [с, b] ]
)</strong></p>

<p>должна отпечатать соответствующую ситуацию,
например так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>е &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; с<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ================</strong></p>

<hr>

<p align="center"><a href="ch11_1.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch11_3.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

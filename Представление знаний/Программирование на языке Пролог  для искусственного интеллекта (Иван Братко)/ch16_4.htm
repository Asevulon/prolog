<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 16. Пункт 4</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch16_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="some_answers.htm">Вперёд</a></p>
<script language="JavaScript">double_line();</script>


<h4>16. 4.&nbsp;&nbsp;&nbsp; Заключительные замечания</h4>

<p>Нашего простого интерпретатора было вполне
достаточно для того, чтобы проиллюстрировать
некоторые идеи, лежащие в основе
программирования в терминах образцов.
Применение этого интерпретатора для более
сложных приложений потребовало бы его доработки
в целом ряде направлений. Ниже приводится
несколько критических замечаний, а также ряд
конкретных предложений по усовершенствованию
алгоритма интерпретации.</p>

<p>Задача разрешения конфликтов была сведена в
нашем интерпретаторе к введению заранее
заданного фиксированного порядка рассмотрения
модулей. Часто возникает необходимость в более
гибких механизмах. Для обеспечения более тонкого
управления интерпретацией следует подавать все
обнаруженные потенциально активные модули на
вход специального управляющего модуля,
запрограммированного пользователем.</p>

<p>Когда база данных велика, а программа содержит
большое количество модулей, процесс
сопоставления с образцами становится крайне
неэффективным. Неэффективность можно уменьшить,
усложнив организацию базы данных. В частности,
можно ввести индексирование информации,
записанной в базе данных, или разбить эту
информацию на отдельные &quot;подбазы данных&quot;,
или же разбить все множество модулей на
отдельные подмножества. Идея разбиения - в каждый
момент дать доступ только к некоторому <em>подмножеству</em>
базы данных или набора модулей, ограничив тем
самым сопоставление образцов только этим
подмножеством. Разумеется, в этом случае
механизм управления должен усложниться,
поскольку он должен будет обеспечить переход от
одних подмножеств к другим с целью их
активизации либо деактивизации. Для этого можно
применить специальные метаправила.</p>

<p>К сожалению, наш интерпретатор
запрограммирован таким образом, что он блокирует
механизм автоматических возвратов, так как для
манипулирования базой данных он использует
процедуры <strong>assert</strong> и <strong>retract</strong>. Это
положение можно исправить, применив другой
способ реализации базы данных, не требующий
обращения к этим встроенным процедурам.
Например, все состоять базы данных можно
представить одним прологовским термом,
передаваемым в процедуру <strong>пуск</strong> в
качестве аргумента. Простейший способ
реализации этой идеи - организовать этот терм в
виде списка объектов базы данных. Тогда верхний
уровень базы данных примет вид:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>пуск( Состояние) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Условие ---&gt; Действие,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
проверить( Условие, Состояние),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
выполнить( Действие, Состояние).</strong></p>

<p>Задача процедуры <strong>выполнить</strong> - получить
новое состояние базы данных и обратиться к
процедуре <strong>пуск</strong>, подав на ее вход это
новое состояние.</p>

<h4>Проект</h4>

<p>Запрограммируйте интерпретатор, который, в
соответствии с приведенным выше замечанием,
реализует базу данных как аргумент пусковой
процедуры и не использует для этого внутренней
базы данных пролог-системы (т. е. обходится без <strong>assert</strong>
и <strong>retract</strong>). Эта новая версия интерпретатора
будет допускать автоматические возвраты.
Попытайтесь разработать такое представление
базы данных, которое облегчало бы сопоставление
с образцами.</p>

<h4>Резюме</h4>

<ul>
  <li>Архитектура, ориентированная на типовые
    конфигурации (образцы), хорошо приспособлена для
    решения многих задач искусственного интеллекта.</li>
  <li>Программа, управляемая образцами, состоит из
    модулей, запускаемых при возникновении в базе
    данных тех или иных конфигураций.</li>
  <li>Прологовские программы можно рассматривать как
    частный случай систем, управляемых образцами.</li>
  <li>Параллельная реализация - наиболее
    естественный способ реализации систем,
    управляемых образцами. Реализация на
    последовательной машине требует разрешения
    конфликтов между модулями, содержащимися в
    конфликтном множестве.</li>
  <li>В этой главе был реализован простой
    интерпретатор для программ, управляемых
    образцами. Он был затем применен к задаче
    автоматического доказательства теорем
    пропозициональной логики.</li>
  <li>Были рассмотрены следующие понятия:<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; системы, управляемые
    образцами<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; архитектуры,
    ориентированные на образцы<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; программирование в
    терминах образцов<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; модули, управляемые
    образцами<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; конфликтное множество,
    разрешение конфликтов<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; принцип резолюции<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; автоматическое
    доказательство теорем на<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    основе принципа резолюции</li>
</ul>

<h4>Литература</h4>

<p>Waterman and Hayes-Roth (1978) - классическая книга по
системам, управляемым образцами. В книге Nilsson (1980)
можно найти фундаментальные понятия,
относящиеся к задаче автоматического
доказательства теорем, включая алгоритм
преобразования логических формул в
конъюнктивную нормальную форму. Прологовская
программа для выполнения этого преобразования
приведена в Clocksin and Mellish (1981).</p>

<p>Clocksin F. W. and Mellish С S. (1981). <em>Programming in Prolog.</em> Springer-
Verlag. [Имеется перевод: Клоксин У., Мелиш К.
Программирование на языке Пролог. - М.: Мир, 1987.]</p>

<p>Nilsson N. J. (1980). <em>Principles of Artificial Intelligence.</em> Tioga;
Springer-Verlag.</p>

<p>Waterman D. A. and Hayes-Roth F. (1978, eds). <em>Pattern-Directed Inference Systems.</em>
Academic Press.</p>

<hr>

<p align="center"><a href="ch16_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="some_answers.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Предисловие</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="preface_trans.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="preface_author.htm">Вперёд</a></p>

<hr>

<h3>ПРЕДИСЛОВИЕ </h3>

<p>В средние века знание латинского и греческого
языков являлось существенной частью образования
любого ученого. Ученый, владеющий только одним
языком, неизбежно чувствовал себя неполноценным,
поскольку он был лишен той полноты восприятия,
которая возникает благодаря возможности
посмотреть на мир сразу с двух точек зрения.
Таким же неполноценным ощущает себя сегодняшний
исследователь в области искусственного
интеллекта, если он не обладает основательным
знакомством как с Лиспом, так и с Прологом - с
этими двумя основополагающими языками
искусственного интеллекта, без знания которых
невозможен более широкий взгляд на предмет
исследования. </p>

<p>Сам я приверженец Лиспа, так как воспитывался в
Массачусетском технологическом институте, где
этот язык был изобретен. Тем не менее, я никогда
не забуду того волнения, которое я испытал,
увидев в действии свою первую программу,
написанную в прологовском стиле. Эта программа
была частью знаменитой системы Shrdlu Терри
Винограда. Решатель задач, встроенный в систему,
работал в &quot;мире кубиков&quot; и заставлял руку
робота (точнее, ее модель) перемещать кубики на
экране дисплея, решая при этом хитроумные задачи,
поставленные оператором. </p>

<p>Решатель задач Винограда был написан на
Микропленнере, языке, который, как мы теперь
понимаем, был своего рода Прологом в миниатюре.
Любой прологоподобный язык заставляет
программиста мыслить в терминах целей, поэтому,
несмотря на все недостатки Микропленнера,
достоинством этой программы было то, что в ее
структуре содержались многочисленные явные
указания на те или иные цели. Процедуры-цели
&quot;схватить&quot;, &quot;освободить&quot;,
&quot;избавиться&quot;, &quot;переместить&quot;,
&quot;отпустить&quot; и т.п. делали программу простой и
компактной, а поведение ее казалось поразительно
разумным. </p>

<p>Решатель задач Винограда навсегда изменил мое
программистское мышление. Я даже переписал его
на Лиспе и привел в своем учебнике по Лиспу в
качестве примера - настолько эта программа
всегда поражала меня мощью заложенной в ней
философии &quot;целевого&quot; программирования, да и
само программирование в терминах целей всегда
доставляло мне удовольствие. </p>

<p>Однако учиться целевому программированию на
примерах лисповских программ - это все равно, что
читать Шекспира на языке, отличном от
английского. Какое-то впечатление вы получите, но
сила эстетического воздействия будет меньшей,
чем при чтении оригинала. Аналогично этому,
лучший способ научиться целевому
программированию - это читать и писать программы
на Прологе, поскольку сама сущность Пролога как
раз и состоит в программировании в терминах
целей. </p>

<p>В самом широком смысле слова эволюция языков
программирования - это движение от языков
низкого уровня, пользуясь которыми, программист
описывает, <em>как</em> что-либо следует делать, к
языкам высокого уровня, на которых просто
указывается, <em>что</em> необходимо сделать. Так,
например, появление Фортрана освободило
программистов от необходимости разговаривать с
машиной на прокрустовом языке адресов и
регистров. Теперь они уже могли говорить на своем
(или почти на своем) языке, только изредка делая
уступки примитивному миру 80-колонных перфокарт. </p>

<p>Однако Фортран и почти все другие языки
программирования все еще остаются языками типа
&quot;как&quot;. И чемпионом среди этих языков
является, пожалуй, современный
модернизированный Лисп. Так, скажем, Common Lisp, имея
богатейшие выразительные возможности, разрешает
программисту описывать наиболее
&quot;выразительно&quot; именно то, <em>как</em> что-либо
следует делать. В то же время очевидно, что Пролог
порывает с традициями языков типа &quot;как&quot;,
поскольку он определенным образом направляет
программистское мышление, заставляя
программиста давать определения ситуаций и
формулировать задачи вместо того, чтобы во всех
деталях описывать способ решения этих задач. </p>

<p>Отсюда следует, насколько важен вводный курс по
Прологу для всех студентов, изучающих
вычислительную технику и программирование -
просто не существует лучшего способа понять, что
из себя представляет программирование типа
&quot;что&quot;. </p>

<p>Многие страницы этой книги могут служить
хорошей иллюстрацией того различия, которое
существует между этими двумя стилями
программистского мышления. Например, в первой
главе это различие иллюстрируется на задачах,
относящихся к семейным отношениям. Прологовский
программист дает простое и естественное
описание понятия &quot;дедушка&quot;: дедушка -это
отец родителя. На Прологе это выглядит так: </p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; дедушка( X, Z) :- отец(
X, Y), родитель( Y, Z).</strong> </p>

<p>Как только пролог-система узнала, что такое
дедушка, ей можно задать вопрос, например: кто
является дедушкой Патрика? В обозначениях
Пролога этот вопрос и типичный ответ имеют вид: </p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?-&nbsp; дедушка( X,
патрик). </strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X&nbsp; =&nbsp; джеймс; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X&nbsp; =&nbsp; карл</strong>. </p>

<p>Каким образом решать эту задачу, как
&quot;прочесывать&quot; базу данных, в которой
записаны все известные отношения &quot;отец&quot; и
&quot;родитель&quot;, - это уже забота самой
пролог-системы. Программист только сообщает
системе то, что ему известно, и задает вопросы.
Его в большей степени интересуют знания и в
меньшей - алгоритмы, при помощи которых из этих
знаний извлекается нужная информация. </p>

<p>Поняв, что очень важно научиться Прологу,
естественно задать себе следующий вопрос - как
это сделать. Я убежден, что изучение языка
программирования во многом сходно с изучением
естественного языка. Так, например, в первом
случае может пригодиться инструкция по
программированию точно так же, как во втором -
словарь. Но никто не изучает язык при помощи
словаря, так как слова - это только часть знаний,
необходимых для овладения языком. Изучающий язык
должен кроме того узнать те соглашения, следуя
которым, можно получать осмысленные сочетания
слов, а затем научиться у мастеров слова
искусству литературного стиля. </p>

<p>Точно так же, никто не изучает язык
программирования, пользуясь только инструкцией
по программированию, так как в инструкциях очень
мало или вообще ничего не говорится о том, как
хорошие программисты используют элементарные
конструкции языка. Поэтому необходим учебник,
причем лучшие учебники обычно предлагают
читателю богатый набор примеров. Ведь в хороших
примерах сконцентрирован опыт лучших
программистов, а именно на опыте мы, в основном, и
учимся. </p>

<p>В этой книге первый пример появляется уже на
первой странице, а далее на читателя как из рога
изобилия обрушивается поток примеров
прологовских программ, написанных
программистом-энтузиастом, горячим приверженцем
прологовской идеологии программирования. После
тщательного изучения этих примеров читатель не
только узнает, как &quot;работает&quot; Пролог, но и
станет обладателем личной коллекции
программ-прецедентов, готовых к употреблению: он
может разбирать эти программы на части,
приспосабливать каждую часть к своей задаче, а
затем снова собирать их вместе, получая при этом
новые программы. Такое усвоение предшествующего
опыта можно считать первым шагом на пути от
новичка к программисту-мастеру. </p>

<p>Изучение хороших программных примеров дает,
как правило, один полезный побочный эффект: мы
узнаем из них не только очень многое о самом
программировании, но и кое-что - о какой-нибудь
интересной научной области. В данной книге такой
научной областью, стоящей за большинством
примеров, является искусственный интеллект.
Читатель узнает о таких идеях в области
автоматического решения задач, как сведение
задач к подзадачам, прямое и обратное построение
цепочки рассуждений, ответы на вопросы &quot;как&quot;
и &quot;почему&quot;, а также разнообразные методы
поиска. </p>

<p>Одним из замечательных свойств Пролога
является то, что это достаточно простой язык, и
студенты могли бы использовать его
непосредственно в процессе изучения вводного
курса по искусственному интеллекту. Я не
сомневаюсь, что многие преподаватели включат эту
книгу в свои курсы искусственного интеллекта с
тем, чтобы студенты смогли увидеть, как при
помощи Пролога абстрактные идеи приобретают
конкретные и действенные формы. </p>

<p>Полагаю, что среди учебников по Прологу эта
книга окажется особенно популярной, и не только
из-за своих хороших примеров, но также из-за
целого ряда других своих привлекательных черт: 

<ul>
  <li>тщательно составленные резюме появляются на
    всем протяжении книги; </li>
  <li>все вводимые понятия подкрепляются
    многочисленными упражнениями;</li>
  <li>процедуры выборки элементов структур подводят
    нас к понятию абстракции данных; </li>
  <li>обсуждение вопросов стиля и методологии
    программирования занимает целую главу; </li>
  <li>автор не только показывает приятные свойства
    языка, но и со всей откровенностью обращает наше
    внимание на трудные проблемы, возникающие при
    программировании на Прологе. </li>
</ul>

<p>Все это говорит о том, что перед нами прекрасно
написанная, увлекательная и полезная книга. </p>

<p align="right">Патрик Г. Уинстон </p>

<p align="right">Кеймбридж, Массачусетс<br>
Январь 1986</p>

<hr>

<p align="center"><a href="preface_trans.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="preface_author.htm">Вперёд</a></p>
</body>
</html>

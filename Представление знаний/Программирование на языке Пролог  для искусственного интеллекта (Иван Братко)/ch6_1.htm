<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 6. Пункт 1</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch5_4.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch6_2.htm">Вперёд</a></p>

<hr>

<h3 align="center">Глава 6</h3>

<h3 align="center">ВВОД И ВЫВОД</h3>

<p>В этой главе мы рассмотрим некоторые
встроенные средства для записи данных в файл и
считывания их из файла. Такие средства можно
также применять и для форматирования объектов
данных программы, чтобы получить желаемую форму
их внешнего представления. Одновременно мы
рассмотрим и средства синтеза и декомпозиции
атомов<a name="tn319">.</p>
</a><a name="p6_1"><script language="JavaScript">double_line();</script>
</a>

<h4>6. 1.&nbsp;&nbsp;&nbsp; <span id="t319">Связь с файлами</span></h4>

<p>До сих пор мы применяли только один метод связи
пользователя с программой - пользователь задает
программе вопросы, а программа ему отвечает,
конкретизируя переменные. Такой механизм связи
прост и практичен и, несмотря на свою простоту,
обеспечивает ввод и вывод информации. Однако он
обладает слишком малой гибкостью и поэтому часто
не совсем удобен. В следующих случаях требуется
расширение этого основного механизма связи: 

<ul>
  <li>ввод данных в форме, отличной от вопроса -
    например, в виде предложений, написанных на
    английском языке</li>
  <li>вывод информации в произвольном формате</li>
  <li>обмен информацией с произвольным файлом, а не
    только с пользовательским терминалом</li>
</ul>

<p>Встроенные предикаты, предназначенные для
этого расширения, отличаются в разных
реализациях Пролога. Мы изучим здесь простой и
удобный набор таких</p>

<p align="center"><img src="pic/fig6_1.gif" width="423" height="214"
alt="fig6_1.gif (2071 bytes)"></p>

<p align="center"><small><strong>Рис. 6. 1.</strong>&nbsp; <a name="tn223"><span
id="t223">Связь между пролог-программой и различными
файлами</span>.</small></p>

<p>предикатов, применяемый во многих реализациях.
Однако за деталями и специфическими
особенностями следует, конечно, обращаться к
руководствам по конкретным пролог-системам.</p>

<p>Рассмотрим вначале вопрос о том, как
обмениваться информацией с файлами, а затем - как
можно вводить и выводить данные в разных
форматах.</p>

<p>На рис. 6.1 показана общая ситуация, в которой
пролог-программа взаимодействует с несколькими</a><a
name="tn224"> файлами. Она может, в принципе, считывать
данные из нескольких входных </a><a name="tn225">файлов,
называемых также <em><span id="t224">входными потоками</span></em>,
и выводить данные в несколько выходных файлов,
называемых <em><span id="t225">выходными потоками</span></em>.
Информация, поступающая с пользовательского
терминала, рассматривается просто как еще один
входной поток. Аналогично информация, выводимая
на этот терминал, рассматривается как один из
выходных </a><a name="tn318">потоков. На оба этих
&quot;псевдофайла&quot; ссылаются с помощью имени <strong><span
id="t318">user</span></strong> (пользователь). Имена остальных
файлов программист должен выбирать в
соответствии с правилами именования файлов,
принятыми в используемой компьютерной системе.</p>

<p>В каждый момент выполнения пролог-программы
лишь два файла являются &quot;активными&quot;: один
для ввода, другой - для вывода. Эти два файла
называются <em>текущим входным потоком</em> и <em>текущим
выходным потоком</em> соответственно. В начальный
момент эти два потока соответствуют терминалу.
Текущий входной поток может быть заменен на
другой файл <strong>ИмяФайла</strong> посредством </a><a
name="tn73">цели</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span id="t73">see(
ИмяФайла)</span></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( Смотри(ИмяФайла) )</p>

<p>Такая цель всегда успешна (если только с файлом <strong>ИмяФайла</strong>
все в порядке), а в качестве побочного эффекта
происходит переключение ввода с предыдущего
входного потока на файл <strong>ИмяФайла</strong>.
Поэтому типичным примером использования
предиката <strong>see</strong> является следующая
последовательность целей, которая считывает
информацию из файла <strong>файл1</strong>, а затем
переключается обратно на терминал:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>. . .<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; see( файл1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; читать_из_файла(
Информация),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; see( user),</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( user - пользователь)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>. . .</strong></p>

<p>Текущий выходной поток может быть изменен при
помощи цели </a><a name="tn78">вида</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span id="t78">tell(
ИмяФайла)</span></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( сообщить( ИмяФайла) )</p>

<p>Следующая последовательность целей выводит
некоторую информацию в <strong>файл3</strong>, а после
этого перенаправляет последующий вывод обратно
на терминал:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>. . .<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tell( файл3),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; записать_в_файл(
Информация),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tell( user),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . .</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </a><a name="tn74">Цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span id="t74">seen</span></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( конец чтения)</p>

<p>закрывает текущий входной файл. </a><a name="tn79">Цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span id="t79">told</span></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
( конец записи)</p>

<p>закрывает текущий выходной файл.</p>

<p>Файлы могут обрабатываться только
последовательно. В этом смысле все файлы ведут
себя так же, как терминал. Каждый запрос на чтение
из входного файла приводит к чтению в текущей
позиции текущего входного потока. После этого
чтения текущая позиция, естественно, будет
перемещена на следующий, еще не прочитанный
элемент данных. Следующий запрос на чтение
приведет к считыванию, начиная с этой новой
текущей позиции. Если запрос на чтение делается в
конце файла, то в качестве ответа на такой запрос
выдается атом <strong>end_of_file</strong> (конец файла).
Считанную один раз информацию считать вторично
невозможно.</p>

<p>Запись производится точно так же, каждый запрос
на вывод информации приведет к тому, что она
будет присоединена в концу текущего выходного
потока. Невозможно сдвинуться назад и переписать
часть файла.</p>

<p>Все файлы являются &quot;текстовыми&quot;, т. е.
файлами, состоящими из символов. Символы - это
буквы, цифры и специальные знаки. О некоторых из
них говорят, что они непечатаемые, поскольку,
будучи выведенными на терминал, они не
появляются на экране. Однако их присутствие
может сказаться каким-либо другим образом,
например появятся пробелы или пустые строки.</p>

<p>Существуют два основных способа, с помощью
которых файлы рассматриваются в Прологе в
зависимости от формы записанной в них
информации. Один способ - рассматривать символ
как основной элемент файла. Соответственно один
запрос на ввод или вывод приведет </a><a name="tn55">к</a><a
name="tn57"> чтению или записи одного символа. Для этой
цели предназначены встроенные предикаты <strong><span
id="t55">get</span></strong>, <strong><span id="t57">get0</span></strong> и <strong>put</strong>
(получить, получить0 и выдать)</a><a name="tn320">.</p>

<p><span id="t320">Другой способ рассматривать файл</span> -
считать, что в качестве основных элементов
построения файла используются более крупные
единицы текста. Такой естественной более крупной
единицей является прологовский терм. Поэтому
каждый запрос на ввод/вывод такого типа приведет
к переносу целого терма из текущего входного
потока или в текущий выходной поток
соответственно. Предикатами для переноса термов
являются предикаты <strong>read</strong> и <strong>write</strong>
(читать и писать). В этом случае информация в
файле должна, конечно, по форме соответствовать
синтаксису термов.</p>

<p>Очевидно, что выбор формы организации файла
зависит от задачи. Всякий раз, когда особенности
задачи допускают естественное представление
информации в соответствии с синтаксисом термов,
следует предпочесть файлы, состоящие из термов.
Тогда появится возможность за одно обращение и
вводу или выводу пересылать целые осмысленные
фрагменты информации. С другой стороны,
существуют задачи, природа которых диктует иную
организацию файлов. Примером такого рода задачи
является обработка предложений естественного
языка, скажем, для организации диалога между
системой и пользователем на английском языке. В
таких случаях файлы следует рассматривать как
последовательности символов, которые не
укладываются в синтаксис термов.</p>

<hr>
</a>

<p align="center"><a href="ch5_4.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch6_2.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 15. Пункт 4</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch15_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch15_5.htm">Вперёд</a></p>
<a name="tn166"><script language="JavaScript">double_line();</script>


<h4>15. 4.&nbsp;&nbsp;&nbsp; <span id="t166">Минимаксные игровые
программы</span>: усовершенствования и ограничения</h4>

<p>Минимаксный принцип и альфа-бета алгоритм
лежат в основе многих удачных игровых программ,
чаще всего шахматных. Общая схема подобной
программы такова: произвести альфа-бета поиск из
текущей позиции вплоть до некоторого предела по
глубине (диктуемого временными ограничениями
турнирных правил).</a> Для оценки терминальных<a
name="tn202"> поисковых позиций использовать
подобранную специально для данной игры <span id="t202">оценочную
функцию</span>. Затем выполнить на игровой доске
наилучший ход, найденный альфа-бета алгоритмом,
принять ответный ход противника и запустить тот
же цикл с начала.</p>

<p>Таким образом, две основных составляющих
игровой программы - это альфа-бета алгоритм и
эвристическая оценочная функция. Для того, чтобы
создать действительно хорошую программу для
такой сложной игры, как шахматы, необходимо
внести в эту базовую схему много различных
усовершенствований. Ниже приводится краткое
описание некоторых из стандартных приемов.</p>

<p>Многое зависит от оценочной функции. Если бы мы
располагали абсолютно точной оценочной
функцией, мы могли бы ограничить поиск
рассмотрением только непосредственных
преемников текущей позиции, фактически исключив
перебор. Но для таких игр, как шахматы, любая
оценочная функция, имеющая практически
приемлемую вычислительную сложность, по
необходимости будет всего лишь эвристической
оценкой. Такая оценка базируется на
&quot;статических&quot; свойствах позиции (например,
на количестве фигур) и в одних позициях работает
надежнее, чем в других. Допустим, например, что мы
имеем именно такую оценочную функцию, основанную
на соотношении материала, и представим себе
позицию, в которой у белых лишний конь. Ясно, что
оценка будет в пользу белых. Здесь все в порядке,
если позиция &quot;спокойная&quot; и черные не
располагают какой-либо сильной угрозой. Но, с
другой стороны, если на следующем ходу черные
могут взять белого ферзя, то такая оценка может
привести к фатальному просмотру из-за своей
неспособности к <em>динамическому</em> восприятию
позиции. Очевидно, что в спокойных позициях мы
можем доверять такой статической оценке в
большей степени, чем в активных позициях, когда с
каждой из сторон имеются непосредственные
угрозы взятия фигур. Поэтому статическую оценку
следует использовать только для спокойных
позиций. Что же касается активных позиций, то
здесь существует такой стандартный прием:
следует продолжить поиск из активной позиции за
пределы ограничения по глубине и продолжать его
до тех пор, пока не встретится спокойная позиция.
В частности, таким образом производится просчет
разменов фигур в шахматах</a><a name="tn345">.</p>

<p>Еще одно усовершенствование - <em><span id="t345">эвристическое
отсечение</span></em> (ветвей). Целью его является
достижение большей предельной глубины поиска за
счет отбрасывания менее перспективных
продолжений. Этот метод позволяет отсекать ветви
в дополнение к тем, которые отсекаются самим
альфа-бета алгоритмом. В связи с этим возникает
риск пропустить какое-нибудь хорошее
продолжение и неправильно вычислить минимаксную
оценку</a><a name="tn218">.</p>

<p>Существует еще один прием, называемый <em><span
id="t218">последовательным углублением</span></em>.
Программа многократно выполняет альфа-бета
поиск сначала до некоторой небольшой глубины, а
затем, увеличивая предел по глубине при каждой
итерации. Процесс завершается, когда истекает
время, отведенное для вычисления очередного
хода. Выполняется наилучший ход, найденный при
наибольшей глубине, достигнутой программой. Этот
метод имеет следующие преимущества: 

<ul>
  <li>он облегчает контроль времени: в момент, когда
    время истекает, всегда имеется некоторый ход -
    лучший из всех, найденных к настоящему моменту;</li>
  <li>минимаксные оценки, вычисленные во время
    предыдущей итерации, можно использовать для
    предварительного упорядочивания позиций в
    следующей итерации, что помогает альфа-бета
    алгоритму следовать стратегии &quot;самые сильные
    ходы - первыми&quot;.</li>
</ul>

<p>Метод последовательного углубления влечет за
собой некоторые накладные расходы (из-за
повторного поиска в верхней части игрового
дерева), но они незначительны по сравнению c
суммарными затратами.</p>

<p>Для наших программ, основанных на описанной</a><a
name="tn349"> выше схеме, существует проблема,
известная как <span id="t349">&quot;эффект горизонта&quot;</span>.
Представьте себе шахматную позицию, в которой
программе грозит неминуемая потеря коня, однако
эту потерю можно отложить, пожертвовав
какую-либо менее ценную фигуру, скажем пешку. Эта
немедленная жертва сможет отодвинуть потерю
коня за пределы доступной глубины поиска (за
&quot;горизонт&quot; программы). Не видя грозящей
опасности, программа отдаст предпочтение
продолжению с жертвой пешки, чтобы избежать
быстрой гибели своего коня. В действительности
программа потеряет <em>обе</em> фигуры - и пешку (без
необходимости), и коня. Эффект горизонта можно
несколько смягчить за счет углубления поиска
вплоть до спокойных позиций.</p>

<p>Существует, однако, более фундаментальное
ограничение на возможности минимаксных игровых
программ, проистекающее из той ограниченной
формы представления знаний, которая в них
используется. Это становится особенно заметным
при сравнении лучших шахматных программ с
шахматными мастерами (людьми). Хорошая программа
просматривает миллионы (и даже больше) позиций,
прежде чем принимает решение об очередном ходе.
Психологические опыты показали, что шахматные
мастера, как правило, просматривают десятки
(максимум, несколько сотен) позиций. Несмотря на
эту явно меньшую производительность,
мастера-шахматисты обыгрывают программы без
особых усилий. Преимущество их состоит в их
знаниях, значительно превосходящих знания
шахматных программ. Игры между машинами и
сильными шахматистами показали, что огромное
превосходство в вычислительной мощности не
способно скомпенсировать недостаток знаний.</p>

<p>Знания в минимаксных игровых программах имеют
следующие три основные формы: 

<ul>
  <li>оценочная функция</li>
  <li>эвристики для отсечения ветвей</li>
  <li>эвристики для распознавания спокойных позиций</li>
</ul>

<p>Оценочная функция сводит все разнообразные
аспекты игровой ситуации к одному числу, и это
упрощение может нанести вред. В
противоположность этому хороший игрок обладает
пониманием позиции, охватывающим многие
&quot;измерения&quot;. Вот пример из области шахмат:
оценочная функция оценивает позицию как равную и
выдает значение 0. Оценка той же позиции, данная
мастером-шахматистом, может быть значительно
более информативной, а также может указывать на
дальнейший ход игры, например: у белых лишняя
пешка, но черные имеют неплохие атакующие
возможности, что компенсирует материальный
перевес, следовательно, шансы равны.</p>

<p>Минимаксные шахматные программы часто хорошо
проявляют себя в острой тактической борьбе,
когда решающее значение имеет точный просчет
форсированных вариантов. Их слабости
обнаруживаются в спокойных позициях, так как они
не способны к долговременному планированию,
преобладающему при медленной, стратегической
игре. Из-за отсутствия плана создается внешнее
впечатление, что программа все время
перескакивает с одной идеи&quot; на другую.
Особенно это заметно в эндшпилях.</p>

<p>В оставшейся части главы мы рассмотрим еще один
подход к программированию игр, основанный на
внесении в программу знаний о типовых ситуациях
при помощи так называемых &quot;советов&quot;.</p>

<hr>
</a>

<p align="center"><a href="ch15_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch15_5.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 16. Пункт 1</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch15_6.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch16_2.htm">Вперёд</a></p>

<hr>

<h3 align="center">Глава 16</h3>

<h3 align="center">ПРОГРАММИРОВАНИЕ В ТЕРМИНАХ ТИПОВЫХ
КОНФИГУРАЦИЙ</h3>

<p>В этой главе мы будем заниматься системами,
ориентированными на типовые конфигурации
(&quot;образцы&quot;), рассматривая их как некоторый
специальный подход к программированию. Языком,
ориентированным на образцы, можно считать и сам
Пролог. Мы реализуем небольшой интерпретатор для
простых программ этого типа и постараемся
передать дух такого &quot;конфигурационной&quot;
программирования на нескольких примерах.</p>
<a name="p16_1"><script language="JavaScript">double_line();</script>
</a>

<h4>16. 1.&nbsp;&nbsp;&nbsp; Архитектура, ориентированная на
типовые конфигурации</h4>
<a name="p16_1_1">

<hr>
</a>

<h4>16. 1. 1.&nbsp;&nbsp;&nbsp; Основные <a name="tn242">понятия</h4>

<p><span id="t242">Под <em>системами, ориентированными на
типовые конфигурации (образцы)</em></span>, мы будем
понимать программные системы специальной
архитектуры. Для некоторых конкретных типов
задач такая архитектура дает преимущества по
сравнению с традиционным способом организации.
Среди задач, которые естественным образом
вписываются в этот вид архитектуры, находятся
многие приложения искусственного интеллекта, в
том числе экспертные системы. Основное различие
между традиционными системами и системами,
ориентированными на образцы, заключается в
механизме запуска программных модулей.
Традиционная архитектура предполагает, что
модули системы обращаются друг к другу в
соответствии с фиксированной, заранее заданной и
явным образом сформулированной схемой. Каждый
программный модуль сам принимает решение о том,
какой из других модулей следует запустить в
данный момент, причем в нем содержится <em>явное</em>
обращение к этим модулям. Соответствующая
временная структура передач управления от одних
модулей к другим оказывается последовательной и
детерминированной.</p>

<p>В противоположность этому организация,
ориентированная на образцы, не предполагает
прямого обращения из одних модулей к другим.
Модули</a><a name="tn170"> запускаются <em>конфигурациями</em>,
возникающими в их &quot;информационной среде&quot;. <span
id="t170">Такие программные модули</a><a name="tn241">
называют модулями, <em>управляемыми типовыми
конфигурациями</em> (или <em>образцами</em>)</span>. <span
id="t241">Программа, управляемая образцами,</span>
представляет из себя набор модулей. Каждый
модуль определяется</p>

<p>&nbsp;&nbsp;&nbsp; (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; образцом,
соответствующим предварительному условию
запуска, и</p>

<p>&nbsp;&nbsp;&nbsp; (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; тем
действием, которое следует выполнить, если
информационная среда<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
согласуется с заданным образцом.</p>

<p>Запуск модулей на выполнение происходит при
появлении тех или иных конфигураций в
информационной среде системы. Такую
информационную среду обычно называют <em>базой
данных</em>. Наглядное представление о системе
рассматриваемого типа дает рис. 16.1.</p>

<p>Следует сделать несколько важных замечаний
относительно рис. 16.1. Совокупность модулей не
имеет иерархической структуры. Отсутствуют
явные указания на то, какие модули могут
обращаться к каким-либо другим модулям. Модули
связаны скорее с базой данных, чем
непосредственно друг с другом. В принципе такая
структура допускает параллельное выполнение
сразу нескольких модулей, поскольку текущее
состояние базы данных может прийти в соот-</p>

<p align="center"><img src="pic/fig16_1.gif" width="507" height="315"
alt="fig16_1.gif (3435 bytes)"></p>

<p align="center"><small><strong>Рис. 16. 1.</strong>&nbsp; Система,
управляемая типовыми конфигурациями (
образцами).</small></p>

<p>ветствие сразу с несколькими предварительными
условиями, а следовательно, в принципе могут
запуститься несколько модулей одновременно. В
связи с этим, подобную организацию можно
рассматривать как естественную модель
параллельных вычислений, имея в виду, что каждый
модуль физически реализован на отдельном
процессоре.</p>

<p>Архитектура, ориентированная на образцы,
обладает рядом достоинств. Одно из ее главных
преимуществ состоит в том, что, разрабатывая
подобную систему, мы не должны тщательно
продумывать и заранее определять все связи между
модулями. Следовательно, каждый модуль может
быть разработан и реализован относительно
автономно. Это придает системе высокую степень
модульности, проявляющуюся, например, в том, что
удаление из системы какого-либо модуля не
обязательно приводит к фатальным последствиям.
После удаления модуля система во многих случаях
сохранит свою способность к решению задач,
измениться может только <em>способ</em> их решения.
Аналогичное соображение верно и в случае
добавления новых модулей или изменения уже
существующих. Заметим, что при введении подобных
модификаций в традиционные системы
потребовалось бы, как минимум, пересмотреть
связи между модулями.</p>

<p>Высокая степень модульности особенно
желательна в системах со сложными базами знаний,
поскольку очень трудно предсказать заранее все
возможные взаимодействия между отдельными
фрагментами знаний. Архитектура,
ориентированная на образцы, обеспечивает
простое решение этой проблемы: каждый фрагмент
знаний, представленный в виде
&quot;если-то&quot;-правила, можно считать отдельным
модулем, запускаемым своим собственным образцом.</p>

<p>Перейдем теперь к более детальной проработке
нашей базовой схемы для систем, ориентированных
на образцы, и рассмотрим вопросы реализации. Как
следует из рис. 16.1, параллельная реализация была
бы для нашей системы наиболее естественным
решением. Тем не менее предположим, что нам
предстоит реализовать ее на традиционном
последовательном процессоре. Тогда если в базе
знаний окажется сразу несколько &quot;пусковых&quot;
конфигураций, относящихся к нескольким модулям,
то возникнет конфликтная ситуация: нам придется
принять решение о том, какой из этих потенциально
активных модулей будет запущен</a><a name="tn151"> в
действительности. Совокупность всех
потенциально активных модулей назовем <em><span
id="t151">конфликтным множеством</span></em>. Очевидно,
что реализация схемы рис. 16.1 на последовательном
процессоре потребует введения в систему
дополнительного,&nbsp; <em>управляющего модуля</em>.
Задача</a> управляющего модуля - выбрать и
активизировать<a name="tn256"> один из модулей
конфликтного множества и тем самым <span id="t256">разрешить
конфликт</span>. Одно из возможных простых правил
разрешения конфликта может основываться,
например, на предварительном упорядочивании
множества модулей системы.</p>

<p>Основной цикл работы системы, ориентированной
на образцы, состоит, таким образом, из трех шагов</a><a
name="tn277">:</p>

<p>&nbsp;&nbsp;&nbsp; (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em><span id="t277">Сопоставление
с образцами</span></em>: найти в базе данных все
конфигурации, сопоставимые с пусковыми
образцами программных модулей. Результат -
конфликтное множество</a><a name="tn257">.</a></p>

<p>&nbsp;&nbsp;&nbsp; (2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em><span id="t257">Разрешение
конфликта</span></em>: выбрать один из модулей,
входящих в конфликтное множество.</p>

<p>&nbsp;&nbsp;&nbsp; (3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Выполнение</em>:
запустить модуль, выбранный на предыдущем шаге.</p>

<p>Этот принцип реализации показан в виде схемы на
рис. 16.2.</p>
<a name="p16_1_2">

<hr>
</a>

<h4>16. 1. 2.&nbsp;&nbsp;&nbsp; Прологовские программы как
системы, управляемые образцами</h4>

<p>Программы, написанные на Прологе, можно
рассматривать как системы, управляемые
образцами. Между пролог-программами и этими
системами можно установить соответствие
примерно следующим образом: 

<ul>
  <li>Каждое предложение прологовской программы
    можно считать отдельным модулем со своим
    пусковым образцом. Голова предложения
    соответствует образцу, тело - тому действию,
    которое выполняет модуль.</li>
  <li>База данных системы - это текущий список целей,
    которые пролог-система пытается удовлетворить.</li>
  <li>Предложение пролог-системы &quot;запускается&quot;,
    если его голова сопоставима с целью,
    расположенной первой в базе данных.</li>
  <li>Выполнить действие модуля (т.е. тело предложе
    ния) - это значит: поместить в базу данных вместо
    первой из целей весь список целей тела
    предложения (с соответствующей конкретизацией
    переменных).</li>
  <li>Процесс активизации модулей (предложений) не
    детерминирован в том смысле, что с первой целью
    базы данных могут удачно сопоставить свою голову
    сразу несколько предложений, и, вообще говоря,
    любое из них может быть запущено. В Прологе этот
    недетерминизм реализован при помощи механизма
    возвратов.</li>
</ul>

<p align="center"><img src="pic/fig16_2.gif" width="434" height="277"
alt="fig16_2.gif (2769 bytes)"></p>

<p align="center"><small><strong>Рис. 16. 2.</strong>&nbsp; Основной цикл
работы системы, управляемой образцами.</small><br>
<small>В этом примере база данных согласуется с
пусковыми образцами</small><br>
<small>модулей&nbsp; 1,&nbsp; 3&nbsp; и&nbsp; 4;&nbsp; для выполнения
выбран модуль&nbsp; 3.</small></p>
<a name="p16_1_3">

<hr>
</a>

<h4>16. 1. 3.&nbsp;&nbsp;&nbsp; Пример составления программы</h4>

<p>С системами, управляемыми образцами, связан
свой особый стиль программирования, требующий
специфического<a name="tn243"> программистского
мышления. Мы говорим в этом случае о <em><span id="t243">программировании
в терминах образцов</span></em>.</p>

<p>В качестве иллюстрации, рассмотрим
элементарное упражнение по программированию -
вычисление наибольшего общего делителя&nbsp; <em>D</em>
&nbsp; двух целых чисел&nbsp; <em>А</em>&nbsp; и&nbsp; <em>В</em>. &nbsp;
Рассмотрим классический алгоритм Евклида:</p>
<script language="JavaScript">line();</script>


<p>Для того, чтобы вычислить наибольший общий
делитель&nbsp; <em>D</em>&nbsp; чисел&nbsp; <em>А</em>&nbsp; и&nbsp; <em>В</em>,
&nbsp; необходимо:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Повторять циклически,
пока&nbsp; <em>А</em>&nbsp; и&nbsp; <em>В</em>&nbsp; не совпадут:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; если&nbsp; <em>А &gt; В</em>, &nbsp;
то заменить&nbsp; <em>А</em>&nbsp; на&nbsp; <em>А - В</em>, &nbsp;
иначе заменить&nbsp; <em>В</em>&nbsp; на&nbsp; <em>В - А</em>.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; После выхода из цикла
&nbsp; <em>А</em>&nbsp; и&nbsp; <em>В</em>&nbsp; совпадают;
наибольший общий делитель&nbsp; <em>D</em>&nbsp; равен<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>А</em>&nbsp; (или&nbsp; <em>В</em>).</p>
<script language="JavaScript">line();</script>


<p>Тот же самый процесс можно описать при помощи
двух модулей, управляемых образцами:</p>

<p><strong>Модуль 1</strong></p>

<p><em>Условие</em>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; В&nbsp; базе
данных существуют такие два числа&nbsp; <em>X</em>&nbsp; и
&nbsp; <em>Y</em>,&nbsp; что&nbsp; <em>X &gt; Y</em>.</p>

<p><em>Действие</em> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Заменить&nbsp; <em>X</em> &nbsp; на разность&nbsp; <em>X - Y</em>.</p>

<p><strong>Модуль 2</strong></p>

<p><em>Условие</em>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; В&nbsp; базе
данных имеется число&nbsp; <em>X</em>.</p>

<p><em>Действие</em> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Выдать результат &nbsp; <em>X</em>&nbsp; и остановиться.</p>

<p>Очевидно, что всегда, когда условие Модуля 1
удовлетворяется, удовлетворяется также и
условие Модуля 2, и мы имеем конфликт. В нашем
случае конфликт можно разрешить при помощи
простого управляющего правила: всегда отдавать
предпочтение Модулю 1. База данных первоначально
содержит числа&nbsp; <em>А</em>&nbsp; и&nbsp; <em>В</em>.</p>

<p>Здесь нас ждет приятный сюрприз: оказывается,
что наша программа способна решать более общую
задачу, а именно, она может вычислять наибольший
общий делитель для любого количества чисел. Если
в базу данных загрузить несколько целых чисел, то
программа выведет их наибольший общий делитель.
На рис. 16.3 показана возможная последовательность
изменений, которые претерпевает база данных
прежде, чем будет получен результат. Обратите
внимание на то, что предварительные условия
модулей могут удовлетворяться одновременно в
нескольких местах базы данных.</p>

<p align="center"><img src="pic/fig16_3.gif" width="221" height="212"
alt="fig16_3.gif (1479 bytes)"></p>

<p align="center"><small><strong>Рис. 16. 3.</strong>&nbsp; Процесс
вычисления наибольшего общего делителя</small><br>
<small>множества чисел. Первоначально база данных
содержит числа</small> <br>
<small>25,&nbsp; 10,&nbsp; 15&nbsp; и&nbsp; 30.&nbsp; Вертикальная
стрелка соединяет число с его</small><br>
<small>&quot;заменителем&quot;. Конечное состояние базы
данных:&nbsp; 5,&nbsp; 5,&nbsp; 5,&nbsp; 5.</small></p>

<p>В данной главе мы реализуем интерпретатор
простого языка для описания систем, управляемых
образцами, и проиллюстрируем на примерах дух
программирования в терминах образцов.</p>

<hr>
</a>

<p align="center"><a href="ch15_6.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch16_2.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

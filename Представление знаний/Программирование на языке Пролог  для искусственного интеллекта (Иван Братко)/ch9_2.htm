<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 9. Пункт 2</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch9_1.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch9_3.htm">Вперёд</a></p>
<script language="JavaScript">double_line();</script>


<h4>9. 2.&nbsp;&nbsp;&nbsp; Представление множеств двоичными
деревьями</h4>

<p>Списки часто применяют для представления
множеств. Такое использование списков имеет тот
недостаток, что проверка принадлежности
элемента множеству оказывается довольно
неэффективной. Обычно предикат <strong>принадлежит(
X, L)</strong> для проверки принадлежности Х к L
программируют так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>принадлежит X, [X | L] ).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; принадлежит X, [ Y | L] )
:-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
принадлежит( X, L).</strong></p>

<p>Для того, чтобы найти Х в списке L, эта процедура
последовательно просматривает список элемент за
элементом, пока ей не встретится либо элемент X,
либо конец списка. Для длинных списков такой
способ крайне неэффективен.</p>

<p>Для облегчения более эффективной реализация
отношения принадлежности применяют различные
древовидные структуры. В настоящем разделе мы
рассмотрим двоичные деревья<a name="tn96">.</p>

<p><span id="t96">Двоичное дерево</span> либо пусто, либо
состоит из следующих трех частей: 

<ul>
  <li>корень</li>
  <li>левое поддерево</li>
  <li>правое поддерево</li>
</ul>

<p>Корень может быть чем угодно, а поддеревья
должны сами быть двоичными деревьями. На рис. 9.4
показано представление множества [а, b, с, d]
двоичным деревом. Элементы множества хранятся в
виде вершин дерева. Пустые поддеревья на рис. 9.4
не показаны. Например, вершина b имеет два
поддерева, которые оба пусты.</p>

<p>Существует много способов представления
двоичных деревьев на Прологе. Одна из простых
возможностей - сделать корень главным функтором
соответствующего терма, а поддеревья - его
аргументами. Тогда дерево рис. 9.4 примет вид</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>а( b, с( d) )</strong></p>

<p>Такое представление имеет среди прочих своих
недостатков то слабое место, что для каждой
вершины дерева нужен свой функтор. Это может
привести к неприятностям, если вершины сами
являются структурными объектами.</p>

<p align="center"><img src="pic/fig9_4.gif" width="323" height="174"
alt="fig9_4.gif (1952 bytes)"></p>

<p align="center"><small><strong>Рис. 9. 4.</strong>&nbsp; Двоичное
дерево.</small></p>

<p>Существует более эффективный и более привычный
способ представления двоичных деревьев: нам
нужен специальный символ для обозначения
пустого дерева и функтор для построения
непустого дерева из трех компонент ( корня и двух
поддеревьев). Относительно функтора и
специального символа сделаем следующий выбор: 

<ul>
  <li>Пусть атом <strong>nil</strong> представляет пустое
    дерево.</li>
  <li>В качестве функтора примем <strong>дер</strong>, так что
    дерево с корнем <strong>X</strong>, левым поддеревом <strong>L</strong>
    и правым поддеревом <strong>R</strong> будет иметь вид
    терма <strong>дер( L, X, R)</strong> (см. рис. 9.5).</li>
</ul>

<p>В этом представлении дерево рис. 9.4 выглядит как</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>дер( дер( nil, b, nil), a,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
дер( дер( nil, d, nil), с, nil) ).</strong></p>

<p>Теперь рассмотрим отношение принадлежности,
которое будем обозначать <strong>внутри</strong>. Цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( X, Т)</strong></p>

<p>истинна, если <strong>Х</strong> есть вершина дерева <strong>Т</strong>.
Отношение <strong>внутри</strong> можно определить при
помощи следующих правил:</p>
<script language="JavaScript">line();</script>


<p>Х есть вершина дерева Т, если 

<ul>
  <li>корень дерева Т совпадает с X, или</li>
  <li>Х - это вершина из левого поддерева, или</li>
  <li>Х - это вершина из правого поддерева.</li>
</ul>
<script language="JavaScript">line();</script>


<p align="center"><img src="pic/fig9_5.gif" width="185" height="100"
alt="fig9_5.gif (641 bytes)"></p>

<p align="center"><small><strong>Рис. 9. 5.</strong>&nbsp; Представление
двоичных деревьев.</small></p>

<p>Эти правила непосредственно транслируются на
Пролог следующим образом:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( X, дер( -, X, -) ).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; внутри( X, дер( L, -, -) )
:-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
внутри( X, L).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; внутри( X, дер( -, -, R) )
:-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
внутри( X, R).</strong></p>

<p>Очевидно, что цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( X, nil)</strong></p>

<p>терпит неудачу при любом X.</p>

<p>Посмотрим, как ведет себя наша процедура.
Рассмотрим рис. 9.4. Цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( X, Т)</strong></p>

<p>используя механизм возвратов, находит все
элементы данных, содержащиеся в множестве,
причем обнаруживает их в следующем порядке:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Х = а; Х = b; Х = с; X = d</strong></p>

<p>Теперь рассмотрим вопрос об эффективности.
Цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( а, Т)</strong></p>

<p>достигается сразу же после применения первого
предложения процедуры <strong>внутри</strong>. С другой
стороны, цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( d, Т)</strong></p>

<p>будет успешно достигнута только после
нескольких рекурсивных обращений. Аналогично
цель</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( е, Т)</strong></p>

<p>потерпит неудачу только после того, как будет
просмотрено все дерево в результате
рекурсивного применения процедуры <strong>внутри</strong>
ко <em>всем</em> поддеревьям дерева Т.</p>

<p>В этом последнем случае мы видим такую же
неэффективность, как если бы мы представили
множество просто списком. Положение можно
улучшить, если между элементами множества
существует отношение порядка. Тогда можно
упорядочить данные в дереве слева направо в
соответствии с этим отношением.</p>

<p align="center"><img src="pic/fig9_6.gif" width="327" height="178"
alt="fig9_6.gif (1219 bytes)"></p>

<p align="center"><small><strong>Рис. 9. 6.</strong>&nbsp; Двоичный
справочник. Элемент 6 найден после прохода по
отмеченному пути 5--&gt;8--&gt;6.</small></p>

<p>Будем говорить, что непустое дерево <strong>дер(
Лев, X, Прав)</strong> упорядочено слева направо, если</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; все вершины левого
поддерева <strong>Лев</strong> меньше X;</p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; все вершины правого
поддерева <strong>Прав</strong> больше X;</p>

<p>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; оба поддерева
упорядочены</a><a name="tn100">.</p>

<p>Будем называть такое двоичное дерево <em><span
id="t100">двоичным справочником</span></em>. Пример
показан на рис. 9.6.</p>

<p>Преимущество упорядочивания состоит в том, что
для поиска некоторого объекта в двоичном
справочнике всегда достаточно просмотреть не
более одного поддерева. Экономия при поиске
объекта Х достигается за счет того, что, сравнив Х
с корнем, мы можем сразу же отбросить одно из
поддеревьев. Например, пусть мы ищем элемент 6 в
дереве, изображенной на рис. 9.6. Мы начинаем с
корня 5, сравниваем 6 с 5, получаем 6 &gt; 5. Поскольку
все элементы данных в левом поддереве должны
быть меньше, чем 5, единственная область, в
которой еще осталась возможность найти элемент 6,
- это правое поддерево. Продолжаем поиск в правом
поддереве, переходя к вершине 8, и т.д</a><a name="tn103">.</p>

<p><span id="t103">Общий метод поиска в двоичном
справочнике</span> состоит в следующем:</p>
<script language="JavaScript">line();</script>


<p>Для того, чтобы найти элемент Х в справочнике Д,
необходимо: 

<ul>
  <li>если Х - это корень справочника Д, то считать, что
    Х уже найден, иначе</li>
  <li>если Х меньше, чем корень, то искать Х в левом
    поддереве, иначе</li>
  <li>искать Х в правом поддереве;</li>
  <li>если справочник Д пуст, то поиск терпит неудачу.</li>
</ul>
<script language="JavaScript">line();</script>


<p>Эти правила запрограммированы в виде
процедуры, показанной на рис. 9.7. Отношение <strong>больше(
X, Y)</strong>, означает, что Х больше, чем Y. Если
элементы, хранимые в дереве, - это числа, то под
&quot;больше, чем&quot; имеется в виду просто Х &gt; Y.</p>

<p>Существует способ использовать процедуру <strong>внутри</strong>
также и для <em>построения</em> двоичного
справочника. Например, справочник Д, содержащий
элементы 5, 3, 8, будет построен при помощи
следующей последовательности целей:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; внутри( 5, Д),
внутри( 3, Д), внутри( 8, Д).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Д = дер( дер( Д1, 3, Д2),
5, дер( Д3, 8, Д4) ).</strong></p>

<p>Переменные Д1, Д2, Д3 и Д4 соответствуют четырем
неопределенным поддеревьям. Какими бы они ни
были, все равно дерево Д будет содержать заданные
элементы 3, 5 и 8. Структура построенного дерева
зависит от того порядка, в котором указываются
цели (рис. 9.8).</p>
<script language="JavaScript">line();</script>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( X, дер( _, X, _ ).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; внутри( X, дер( Лев,
Корень, Прав) ) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
больше( Корень, X),</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <small>%
Корень больше, чем Х</small><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>внутри( X, Лев).</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Поиск в левом поддереве</small></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( X, дер( Лев,
Корень, Прав) ) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
больше( X, Корень),</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <small>% Х
больше, чем корень</small><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>внутри( X, Прав).</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Поиск в правом поддереве</small></p>
<script language="JavaScript">line();</script>


<p align="center"><small><strong>Рис. 9. 7.</strong>&nbsp; Поиск элемента
Х в двоичном справочнике.</small></p>
</a>

<p align="center">&nbsp;</p>

<p align="center"><img src="pic/fig9_8.gif" width="552" height="252"
alt="fig9_8.gif (2576 bytes)"></p>
<a name="tn103">

<p align="center"><small><strong>Рис. 9. 8.</strong>&nbsp; (а) &nbsp;&nbsp;&nbsp;
Дерево <strong>Д</strong>, построенное как результат
достижения целей: <strong>внутри( 5, Д)</strong>, <strong>внутри(
3, Д)</strong>, <strong>внутри( 8, Д)</strong>. &nbsp;&nbsp;&nbsp;
(b)&nbsp;&nbsp;&nbsp; Дерево, полученное при другом
порядке целей: <strong>внутри( 5, Д)</strong>, <strong>внутри( 3,
Д)</strong>, <strong>внутри( 8, Д)</strong>.</small></p>

<p>Здесь уместно сделать несколько замечаний
относительно эффективности поиска в
справочниках. Вообще говоря, поиск элемента в
справочнике эффективнее, чем поиск в списке. Но
насколько? Пусть <em>n</em> - число элементов
множества. Если множество представлено списком,
то ожидаемое время поиска будет пропорционально
его длине <em>n</em>. В среднем нам придется
просмотреть примерно половину списка. Если
множество представлено двоичным деревом, то
время поиска будет пропорционально глубине
дерева. Глубина дерева - это длина самого
длинного пути между корнем и листом дерева.
Однако следует помнить, что глубина дерева
зависит от его формы</a><a name="tn112">.</p>

<p>Мы говорим, что <span id="t112">дерево (приближенно)
сбалансировано</span>, если для каждой вершины
дерева соответствующие два поддерева содержат
примерно равное число элементов. Если дерево
хорошо сбалансировано, то его глубина
пропорциональна log <em>n</em>. В этом случае мы
говорим, что дерево имеет логарифмическую
сложность. Сбалансированный справочник лучше
списка настолько же, насколько log <em>n</em> меньше <em>n</em>.
К сожалению, это верно только для приближенно
сбалансированного дерева. Если происходит
разбалансировка дерева, то производительность
падает. В случае полностью разбалансированных
деревьев, дерево фактически превращается в
список. Глубина дерева в этом случае равна <em>n</em>,
а производительность поиска оказывается столь
же низкой, как и в случае списка. В связи с этим мы
всегда заинтересованы в том, чтобы справочники
были сбалансированы. Методы достижения этой цели
мы обсудим в гл. 10.</p>

<h4>Упражнения</h4>

<p><strong>9. 9.</strong>&nbsp;&nbsp;&nbsp; Определите предикаты</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>двдерево( Объект)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; справочник( Объект)</strong></p>

<p>распознающие, является ли <strong>Объект</strong>
двоичным деревом или двоичным справочником
соответственно. Используйте обозначения,
введенные в данном разделе.</p>
</a>

<p><a href="javascript:fa('9_9')">Посмотреть ответ</a></p>

<p><strong>9. 10.</strong>&nbsp;&nbsp;&nbsp; Определите процедуру</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>глубина( ДвДерево,
Глубина)</strong></p>

<p>вычисляющую глубину двоичного дерева в
предположении, что глубина пустого дерева равна
0, а глубина одноэлементного дерева равна 1.</p>

<p><a href="javascript:fa('9_10')">Посмотреть ответ</a></p>

<p><strong>9. 11.</strong>&nbsp;&nbsp;&nbsp; Определите отношение</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>линеаризация(
Дерево, Список)</strong></p>

<p>соответствующее &quot;выстраиванию&quot; всех
вершин дерева в список.</p>

<p><a href="javascript:fa('9_11')">Посмотреть ответ</a></p>

<p><strong>9. 12.</strong>&nbsp;&nbsp;&nbsp; Определите отношение</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>максэлемент( Д,
Элемент)</strong></p>

<p>таким образом, чтобы переменная <strong>Элемент</strong>
приняла значение наибольшего из элементов,
хранящихся в дереве <strong>Д</strong>.</p>

<p><a href="javascript:fa('9_12')">Посмотреть ответ</a></p>

<p><strong>9. 13.</strong>&nbsp;&nbsp;&nbsp; Внесите изменения в
процедуру</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>внутри( Элемент,
ДвСправочник)</strong></p>

<p>добавив в нее третий аргумент <strong>Путь</strong>
таким образом, чтобы можно было бы получить путь
между корнем справочника и указанным элементом.</p>

<p><a href="javascript:fa('9_13')">Посмотреть ответ</a></p>

<hr>

<p align="center"><a href="ch9_1.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch9_3.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

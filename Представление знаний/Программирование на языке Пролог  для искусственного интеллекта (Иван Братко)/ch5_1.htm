<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 5. Пункт 1</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch4_5.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch5_2.htm">Вперёд</a></p>

<hr>

<h3 align="center">Глава 5</h3>

<h3 align="center">УПРАВЛЕНИЕ <a name="tn204">ПЕРЕБОРОМ</h3>

<p>Мы уже видели, что программист <span id="t204">может
управлять процессом вычислений по программе</span>,
располагая ее предложения и цели в том или ином
порядке. В данной главе мы рассмотрим еще одно
средство управления, получившее название
&quot;отсечение&quot; (cut) и предназначенное для
ограничения автоматического перебора</a><a name="tn203">.</p>
</a><a name="p5_1"><script language="JavaScript">double_line();</script>
</a>

<h4>5. 1.&nbsp;&nbsp;&nbsp; <span id="t203">Ограничение перебора</span></h4>

<p>В процессе достижения цели пролог-система
осуществляет автоматический перебор вариантов,
делая возврат при неуспехе какого-либо из них.
Такой перебор - полезный программный механизм,
поскольку он освобождает пользователя от
необходимости программировать его самому. С
другой стороны, ничем не ограниченный перебор
может стать источником</p>

<p align="center"><img src="pic/fig5_1.gif" width="326" height="270"
alt="fig5_1.gif (1049 bytes)"></p>

<p align="center"><small><strong>Рис. 5. 1.</strong> &nbsp;
Двухступенчатая функция</small></p>

<p>неэффективности программы. Поэтому иногда<a
name="tn185"> требуется его ограничить или исключить
вовсе. Для этого <span id="t185">в Прологе предусмотрена
конструкция &quot;отсечение&quot;</span>.</p>

<p>Давайте сначала рассмотрим простую программу,
процесс вычислений, по которой содержит ненужный
перебор. Мы выделим те точки этого процесса, где
перебор бесполезен и ведет к неэффективности.</p>

<p>Рассмотрим двухступенчатую функцию,
изображенную на рис. 5.1. Связь между Х и Y можно
определить с помощью следующих трех правил:</p>

<p><em>Правило 1</em>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; если Х &lt;
3, то Y = 0</p>

<p><em>Правило 2</em>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; если 3 &lt;= X
и Х &lt; 6, то Y = 2</p>

<p><em>Правило 3</em>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; если 6 &lt;=
X, то Y = 4</p>

<p>На Прологе это можно выразите с помощью
бинарного отношения</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>f( X, Y)</strong></p>

<p>так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>f( X, 0) :- X &lt; 3.</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Правило 1</small></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>f( X, 2) :- 3 =&lt; X,&nbsp; X &lt;
6.</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <small>%
Правило 2</small></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>f( X, 4) :- 6 =&lt; X.</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Правило 3</small></p>

<p>В этой программе предполагается, конечно, что к
моменту начала вычисления&nbsp; <strong>f( X, Y)</strong>&nbsp; <strong>Х</strong>
&nbsp; уже конкретизирован каким-либо числом; это
необходимо для выполнения операторов сравнения.</p>

<p>Мы проделаем с этой программой два
эксперимента. Каждый из них обнаружит в ней свой
источник неэффективности, и мы устраним оба этих
источника по очереди, применив оператор
отсечения.</p>
</a><a name="p5_1_1">

<hr>
</a>

<h4>5. 1. 1.&nbsp;&nbsp;&nbsp; Эксперимент 1</h4>

<p>Проанализируем, что произойдет, если задать
следующий вопрос:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; f( 1, Y),&nbsp; 2 &lt; Y.</strong></p>

<p align="center"><img src="pic/fig5_2.gif" width="404" height="336"
alt="fig5_2.gif (2884 bytes)"></p>

<p align="center"><a name="tn199"><small><strong>Рис. 5. 2.</strong>&nbsp; В
точке, помеченной словом <span id="t199">&quot;ОТСЕЧЕНИЕ&quot;</span>,
уже известно,</small><br>
<small>что правила&nbsp; 2&nbsp; и&nbsp; 3&nbsp; должны
потерпеть неудачу.</small></p>

<p>При вычислении первой цели&nbsp; <strong>f( l, Y)</strong>
&nbsp; Y конкретизируется нулем. Поэтому вторая цель
становится такой:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>2 &lt; 0</strong></p>

<p>Она терпит неудачу, а поэтому и весь список
целей также терпит неудачу. Это очевидно, однако
перед тем как признать, что такому списку целей
удовлетворить нельзя, пролог-система при помощи
возвратов попытается проверить еще две
бесполезные в данном случае альтернативы.
Пошаговое описание процесса вычислений
приводится на рис. 5.2.</p>

<p>Три правила, входящие в отношение <strong>f</strong>,
являются взаимоисключающими, поэтому успех
возможен самое большее в одном из них.
Следовательно, мы (но не пролог-система) знаем,
что, как только успех наступил в одном из них, нет
смысла проверять остальные, поскольку они все
равно обречены на неудачу. В примере, приведенном
на рис. 5.2, о том, что в правиле 1 наступил успех,
становится известно в точке, обозначенной словом
&quot;ОТСЕЧЕНИЕ&quot;. Для предотвращения
бессмысленного перебора мы должны явно указать
пролог-системе, что <em>не нужно</em> осуществлять</a><a
name="tn38"> возврат из этой точки. Мы можем сделать
это при помощи конструкции отсечения. <span id="t38">&quot;Отсечение&quot;
записывается в виде символа <strong>'!'</strong></span>,
который вставляется между целями и играет роль
некоторой псевдоцели. Вот наша программа,
переписанная с использованием отсечения:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>f( X, 0) :- X &lt; 3,&nbsp; !.</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f( X, 2) :- 3 =&lt; X,&nbsp; X &lt;
6,&nbsp; !.</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f( X, 4) :- 6 =&lt; X.</strong></p>

<p>Символ&nbsp; '!'&nbsp; предотвращает возврат из тех
точек программы, в которых он поставлен. Если мы
теперь спросим</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; f( 1, Y),&nbsp; 2 &lt; Y.</strong></p>

<p>то пролог-система породит левую ветвь дерева,
изображенного на рис. 5.2. Эта ветвь потерпит
неудачу на цели&nbsp; <strong>2&nbsp; &lt;&nbsp; 0</strong>. &nbsp;
Система попытается сделать возврат, но вернуться
она сможет не далее точки, помеченной в программе
символом&nbsp;&nbsp; '!' .&nbsp; Альтернативные ветви,
соответствующие правилу 2 и правилу 3, порождены
не будут.</p>

<p>Новая программа, снабженная отсечениями, во
всех случаях более эффективна, чем первая версия,
в которой они отсутствуют. Неудачные варианты
новая программа распознает всегда быстрее, чем
старая.</p>

<p>Вывод: добавив отсечения, мы повысили
эффективность. Если их теперь убрать, программа
породит тот же результат, только на его получение
она истратит скорее всего больше времени. Можно
сказать, что в нашем случае после введения
отсечений мы изменили только процедурный смысл
программы, оставив при этом ее декларативный
смысл в неприкосновенности. В дальнейшем мы
покажем, что использование отсечения может также
затронуть и декларативный смысл программы. </p>
</a><a name="p5_1_2">

<hr>
</a>

<h4>5. 1. 2.&nbsp;&nbsp;&nbsp; Эксперимент 2</h4>

<p>Проделаем теперь еще один эксперимент со
второй версией нашей программы. Предположим, мы
задаем вопрос:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; f( 7, Y).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = 4</strong></p>

<p>Проанализируем, что произошло. Перед тем, как
был получен ответ, система пробовала применить
все три правила. Эти попытки породили следующую
последовательность целей:</p>

<p><em>Попытка применить правило 1:</em></p>

<p>&nbsp;&nbsp;&nbsp; 7&nbsp; &lt;&nbsp; 3&nbsp; терпит неудачу,
происходит возврат, и попытка применить правило 2
(точка отсечения достигнута не была)</p>

<p><em>Попытка применить правило 2:</em></p>

<p>&nbsp;&nbsp;&nbsp; 3&nbsp; &lt;=&nbsp; 7&nbsp; успех, но&nbsp; 7&nbsp; &lt;
&nbsp; 6&nbsp; терпит неудачу; возврат и попытка
применить правило 3 (точка отсечения снова не
достигнута)</p>

<p><em>Попытка применить правило 3:</em></p>

<p>&nbsp;&nbsp;&nbsp; 6&nbsp; &lt;=&nbsp; 7&nbsp; - успех</p>

<p>Приведенные этапы вычисления обнаруживают еще
один источник неэффективности. В начале
выясняется, что&nbsp; <strong>X&nbsp; &lt;&nbsp; 3</strong>&nbsp; не
является истиной&nbsp; (7&nbsp; &lt;&nbsp; 3&nbsp; терпит
неудачу). Следующая цель -&nbsp;&nbsp; <strong>3 =&lt; Х</strong>&nbsp;&nbsp;&nbsp;
(3&nbsp; &lt;=&nbsp; 7- успех).&nbsp; Но нам известно, что, если
первая проверка неуспешна, то вторая обязательно
будет успешной, так как второе целевое
утверждение является отрицанием первого.
Следовательно, вторая проверка лишняя и
соответствующую цель можно опустить. То же самое
верно и для цели&nbsp; <strong>6 =&lt; Х</strong>&nbsp; в правиле 3.
Все эти соображения приводят к следующей, более
экономной формулировке наших трех правил:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; если&nbsp; Х &lt; 3,&nbsp; то&nbsp; Y
= 0</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; иначе, если&nbsp; 3 &lt;= X &nbsp;
и&nbsp; Х &lt; 6,&nbsp; то&nbsp; Y = 2,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; иначе&nbsp; Y = 4.</p>

<p>Теперь мы можем опустить в нашей программе те
условия, которые обязательно выполняются при
любом вычислении. Получается третья версия
программы:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>f( X, 0) :- X &lt; 3,&nbsp; !.</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f( X, 2) :- X &lt; 6,&nbsp; !.</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f( X, 4).</strong></p>

<p>Эта программа дает тот же результат, что и
исходная, но более эффективна, чем обе
предыдущие. Однако, что будет, если мы <em>теперь</em>
удалим отсечения? Программа станет такой:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>f( X, 0) :- X &lt; 3.</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f( X, 2) :- X &lt; 6.</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f( X, 4).</strong></p>

<p>Она может порождать различные решения, часть из
которых неверны. Например:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; f( 1, Y).</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = 2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y = 4;</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nо</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (нет)</p>

<p>Важно заметить, что в последней версии, в
отличие от предыдущей, отсечения затрагивают не
только процедурное поведение, но изменяют также
и декларативный смысл <a name="tn39">программы.</p>

<p><span id="t39">Более точный смысл механизма отсечений</span>
можно сформулировать следующим образом:</p>
<script language="JavaScript">line();</script>


<p>Назовем &quot;целью-родителем&quot; ту цель, которая
сопоставилась с головой предложения,
содержащего отсечение. Когда в качестве цели
встречается отсечение, такая цель сразу же
считается успешной и при этом заставляет систему
принять те альтернативы, которые были выбраны с
момента активизации цели-родителя до момента,
когда встретилось отсечение. Все оставшиеся в
этом промежутке (от цели-родителя до отсечения)
альтернативы не рассматриваются.</p>
<script language="JavaScript">line();</script>


<p>Чтобы прояснить смысл этого определения,
рассмотрим предложение вида</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Н :- В1, В2, ..., Вm, !, ...,
Вn.</strong></p>

<p>Будем считать, что это предложение
активизировалось, когда некоторая цель&nbsp; G &nbsp;
сопоставилась с&nbsp; Н.&nbsp; Тогда&nbsp; G &nbsp; является
целью-родителем. В момент, когда встретилось
отсечение, успех уже наступил в целях&nbsp; <strong>В1,&nbsp;
...,&nbsp; Вm</strong>.&nbsp; При выполнении отсечения это
(текущее) решение&nbsp; <strong>В1, &nbsp; ...,&nbsp; Вm</strong>&nbsp;
&quot;замораживается&quot; и все возможные оставшиеся
альтернативы больше не рассматриваются. Далее,
цель&nbsp; G&nbsp; связывается теперь с этим
предложением: любая попытка сопоставить&nbsp; G&nbsp;
с головой какого-либо другого предложения
пресекается.</p>

<p>Применим эти правила к следующему примеру:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>С :- Р, Q, R, !, S, Т, U.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; С :- V.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; А :- В, С, D.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?-&nbsp; А.</strong></p>

<p>Здесь&nbsp; А,&nbsp; В,&nbsp; С,&nbsp; D,&nbsp; Р&nbsp; и т.д. имеют
синтаксис термов. Отсечение повлияет на
вычисление цели&nbsp; С&nbsp; следующим образом.
Перебор будет возможен в списке целей&nbsp; Р,
&nbsp;&nbsp; Q,&nbsp; R;&nbsp; однако, как только точка
отсечения будет достигнута, все альтернативные
решения для этого списка изымаются из
рассмотрения. Альтернативное предложение,
входящее в&nbsp; С:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>С :- V.</strong></p>

<p>также не будет учитываться. Тем не менее,
перебор будет возможен в списке целей&nbsp; S,&nbsp; Т,
&nbsp; U.&nbsp; &quot;Цель-родитель&quot; предложения,
содержащего отсечения, -это цель&nbsp; С&nbsp; в
предложении</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>А :- В, С, D.</strong></p>

<p>Поэтому отсечение повлияет только на цель&nbsp; С.
&nbsp; С другой стороны, оно будет &quot;невидимо&quot; из
цели&nbsp; А.&nbsp; Таким образом, автоматический
перебор все равно будет происходить в списке
целей&nbsp; В,&nbsp; С,&nbsp; D,&nbsp; вне зависимости от
наличия отсечения в предложении, которое
используется для достижения&nbsp; С.</p>

<hr>
</a>

<p align="center"><a href="ch4_5.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch5_2.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

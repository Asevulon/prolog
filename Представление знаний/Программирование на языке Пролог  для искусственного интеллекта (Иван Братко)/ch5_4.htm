<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 5. Пункт 4</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch5_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch6_1.htm">Вперёд</a></p>
<script language="JavaScript">double_line();</script>


<h4>5. 4.&nbsp;&nbsp;&nbsp; Трудности с отсечением и
отрицанием</h4>

<p>Используя отсечение, мы кое-что выиграли, но не
совсем даром. Преимущества и недостатки
применения отсечения были показаны на примерах
из предыдущих разделов. Давайте подытожим
сначала преимущества:</p>

<p>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; При помощи отсечения
часто можно повысить эффективность программы.
Идея состоит в том, чтобы прямо сказать
пролог-системе: не пробуй остальные
альтернативы, так как они все равно обречены на
неудачу.</p>

<p>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Применяя отсечение,
можно описать взаимоисключающие правила,
поэтому есть возможность запрограммировать
утверждение:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>если</em> условие Р, <em>то</em>
решение Q,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>иначе</em> решение R</p>

<p>Выразительность языка при этом повышается.</p>

<p>Ограничения на использование отсечения
проистекают из того, что есть опасность потерять
такое важное для нас соответствие между
декларативным и процедурным смыслами программы.
Если в программе нет отсечений, то мы можем
менять местами порядок предложений и целей, что
повлияет только на ее эффективность, но не на
декларативный смысл. Если же отсечения в ней
присутствуют, то изменение порядка предложений
может повлиять на ее декларативный смысл. Это
значит, что программа с измененным порядком,
возможно, будет давать результаты, отличные от
результатов исходной программы. Вот пример,
демонстрирующий этот факт:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>р :- а, b.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; р :- с.</strong></p>

<p>Декларативный смысл программы: р истинно тогда
и только тогда, когда истинны одновременно и а, и b
или истинно с. Это можно записать в виде такой
логической формулы:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; р &lt;===&gt; (а &amp; b) <small>U</small>
с</p>

<p>Можно поменять порядок этих двух предложений,
но декларативный смысл останется прежним. Введем
теперь отсечение</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>p :- а,&nbsp; !,&nbsp; b.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; р :- с.</strong></p>

<p>Декларативный смысл станет теперь таким:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; р &lt;===&gt; (а &amp; b) <small>U</small>
( ~а &amp; с)</p>

<p>Если предложения поменять местами</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>р :- с.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; р :- а,&nbsp; !,&nbsp; b.</strong></p>

<p>декларативный смысл станет таким:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; р &lt;===&gt; с <small>U</small> ( а
&amp; b)</p>

<p>Важным моментом здесь является то, что при
использовании отсечения требуется уделять
больше внимания процедурным аспектам. К
несчастью, эта дополнительная трудность
повышает вероятность ошибок программирования.</p>

<p>В наших примерах из предыдущего раздела мы
видели, что удаление отсечений из программы
может привести к изменению ее декларативного
смысла. Но были также в такие случаи, когда
отсечение на него не влияло. Использование
отсечений последнего типа требует меньшей<a
name="tn200"> осторожности, и поэтому такие отсечения
иногда называют <span id="t200">&quot;зелеными
отсечениями&quot;</span>. С точки зрения наглядности
программы такие отсечения &quot;невинны&quot; и их
использование вполне приемлемо. При чтении
программы их можно просто игнорировать</a><a
name="tn201">.</p>

<p><span id="t201">Напротив, отсечения, влияющие на
декларативный смысл, называются &quot;красными&quot;</span>.
Красные отсечения -это такие отсечения, которые
делают программу трудной для понимания, и их
нужно применять с особой осторожностью.</p>

<p>Отсечение часто используется в комбинации со
специальной целью <strong>fail</strong>. В частности, мы
определили отрицание какой-либо цели (<strong>not</strong>),
как ее неуспех. Определенное таким образом
отрицание представляет собой просто особый
(более ограниченный) вид отсечения. Из
соображений ясности программ мы предпочтем
пользоваться <strong>not</strong> вместо комбинации <em>отсечение
- неуспех</em> (всюду, где возможно), поскольку
отрицание является понятием более высокого
уровня, чем <em>отсечение - неуспех</em>.</p>

<p>Следует заметить, что использование оператора <strong>not</strong>
также может приводить к неприятностям, и его тоже
следует применять с осторожностью. Трудность
заключается в том, что тот оператор <strong>not</strong>,
который был нами определен, не в точности
соответствует отрицанию в математике. Если
спросить</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; not человек(
мэри).</strong></p>

<p>система, возможно, ответит &quot;да&quot;. Не следует
понимать этот ответ как &quot;мэри не человек&quot;.
Что в действительности пролог-система хочет
сказать своим &quot;да&quot;, так это то, что программе
не хватает информации для доказательства
утверждения &quot;Мэри - человек&quot;. Это происходит
потому, что при обработке цели <strong>not</strong>
система не пытается доказать истинность этой
цели впрямую. Вместо этого она пытается доказать
противоположное утверждение, и если такое
противоположное утверждение доказать не
удается, система считает, что </a><a name="tn123">цель <strong>not</strong>
- успешна. Такое рассуждение основано на так
называемом <em><span id="t123">предположении о
замкнутости мира</span></em>. В соответствии с этим
постулатом <em>мир замкнут</em> в том смысле, что все
в нем существующее либо указано в программе, либо
может быть из нее выведено. И наоборот - если
что-либо не содержится в программе (или не может
быть из нее выведено), то оно не истинно и,
следовательно, истинно его отрицание. Это
обстоятельство требует особого внимания,
поскольку мы обычно не считаем мир замкнутым:
если в программе явно не сказано, что</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>человек( мэри)</strong></p>

<p>то мы этим обычно вовсе не хотим сказать, что
Мэри не человек.</p>

<p>Дальнейшее изучение опасных аспектов
использования <strong>not</strong> проведем на таком
примере:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>r( а).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g( b).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; р( X) :- not r( X).</strong></p>

<p>Если спросить теперь</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; g( X), р( Х).</strong></p>

<p>система ответит</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Х = b</strong></p>

<p>Если же задать тот же вопрос, но в такой форме</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp; р( X), g( X).</strong></p>

<p>система ответит</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>nо</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (нет)</p>

<p>Читателю предлагается проследить работу
программы по шагам, чтобы понять, почему
получились разные ответы. Основная разница между
вопросами состоит в том, что переменная Х к
моменту вычисления <strong>р( X)</strong> в первом случае
была уже конкретизирована, в то время как во
втором случае этого еще не произошло.</p>

<p>Мы детально обсудили аспекты применения
отсечения, которое неявно присутствует в <strong>not</strong>.
При этом нами руководило желание предупредить
пользователей о соблюдении необходимой
осторожности, а вовсе не желание убедить их
совсем не пользоваться этим оператором.
Отсечение полезно, а часто и необходимо. А что
касается трудностей Пролога, порождаемых
отсечением, то подобные неудобства часто
возникают и при программировании на других
языках.</p>

<h4>Резюме </h4>

<ul>
  <li>Отсечение подавляет перебор. Его применяют как
    для повышения эффективности программ, так и для
    повышения выразительности языка.</li>
  <li>Эффективность повышается путем прямого
    указания (при помощи отсечения) пролог - системе
    не проверять альтернативы, про которые нам
    заранее известно, что они должны потерпеть
    неудачу.</li>
  <li>Отсечение дает возможность сформулировать
    взаимно исключающие утверждения при помощи
    правил вида:<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>если</em> <strong>Условие</strong>
    <em>то</em> <strong>Утверждение1</strong> <em>иначе</em> <strong>Утверждение2</strong><br>
  </li>
  <li>Отсечение дает возможность ввести <em>отрицание
    как неуспех</em>: <strong>not( Цель)</strong> определяется
    через неуспех цели <strong>Цель</strong>.</li>
  <li>Иногда бывают полезными две особые цели <strong>true</strong>
    и <strong>fail</strong>. <strong>true</strong> - всегда успешна и <strong>fail</strong>
    - всегда терпит неудачу.</li>
  <li>Существуют ограничения в применении отсечения:
    его появление может нарушить, соответствие между
    декларативным и процедурным смыслами программы.
    Поэтому хороший стиль программирования
    предполагает осторожное применение отсечений и
    отказ от их применения без достаточных
    оснований.</li>
  <li>Оператор <strong>not</strong>, определенный через
    неуспех, не полностью соответствует отрицанию в
    математической логике. Поэтому <strong>not</strong> тоже
    нужно применять с осторожностью.</li>
</ul>

<h4>Литература</h4>

<p>Различать &quot;зеленые и &quot;красные&quot;
отсечения предложил ван Эмден (1982).</p>

<p>van Emden M. (1982). Red and green cuts. <em>Logic Programming Newsletter:&nbsp; 2</em>.</p>

<hr>
</a>

<p align="center"><a href="ch5_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch6_1.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 2. Пункт 7</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch2_6.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch3_1.htm">Вперёд</a></p>
<a name="tn159"><script language="JavaScript">double_line();</script>


<h4>2. 7.&nbsp;&nbsp;&nbsp; <span id="t159">Замечания о взаимосвязи
между Прологом и логикой</span></h4>

<p>Пролог восходит к математической логике,
поэтому его синтаксис и семантику можно наиболее
точно описать при помощи логики. Так часто и
поступают при обучении этому языку. Однако такой
подход к ознакомлению с Прологом предполагает
знание читателем определенных понятий
математической логики. С другой стороны, знание
этих понятий явно необязательно для того, чтобы
понять и использовать Пролог в качестве
инструмента для практического программирования,
а цель данной книги - научить именно этому. Для
тех же читателей, которые особенно
заинтересуются взаимосвязями между Прологом и
логикой, мы сейчас перечислим основные из них, а
также приведем некоторые подходящие источники</a><a
name="tn160">.</p>

<p>Синтаксис Пролога - это синтаксис предложений <span
id="t160"><em>логики предикатов первого порядка</em></span>,
записанных в так называемой <em>форме предложений</em>
(форме, при которой кванторы не выписываются</a><a
name="tn322"> явно), а точнее, в виде частного случая
таких предложений - в виде <em><span id="t322">формул
Хорна</span></em> (предложений, имеющих самое большее
один положительный литерал). Клоксин и Меллиш (1981
г.) приводят пролог-программу, которая
преобразует предложения исчисления предикатов</a><a
name="tn117"> первого порядка в форму предложений.
Процедурный смысл Пролога основывается на <em><span
id="t117">принципе резолюций</span></em>, применяющемся
для автоматического доказательства теорем,
который был предложен Робинсоном в его
классической статье (1965 г.). В Прологе
используется особая стратегия доказательства
теоремы методом резолюций, носящая название SLD.
Введение в исчисление предикатов первого
порядка и доказательство теорем, основанное на
методе резолюций, можно найти у Нильсона (1981 г.).
Математические вопросы, касающиеся свойств
процедурной семантики Пролога в их связи с
логикой, проанализированы Ллойдом (1984 г.)</a>.</p>

<p><a name="tn317">Сопоставление в Прологе соответствует
некоторому действию в логике, называемому <em><span
id="t317">унификацией</span></em>. Мы, однако, избегаем
слова &quot;унификация&quot;, так как по соображениям
эффективности внести в большинстве
пролог-систем сопоставление реализовано таким
образом, что оно не полностью соответствует
унификации (см. упражнение 2.10). Тем не менее, с
практической точки зрения, такая приближенная
унификация вполне допустима.</p>

<h4>Упражнение</h4>

<p><strong>2. 10.</strong>&nbsp;&nbsp;&nbsp; Что будет, если
пролог-системе задать такой вопрос:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>?-&nbsp;&nbsp; Х&nbsp; =&nbsp; f(
X).</strong></p>

<p>Успешным или неуспешным будет здесь
сопоставление? По определению унификации в
логике, сопоставление должно быть неуспешным, а
что будет в соответствии с нашим определением
сопоставления из раздела 2.2? Попробуйте
объяснить, почему многие реализации Пролога
отвечают на вышеприведенный вопрос так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>X&nbsp; = &nbsp;
f(f(f(f(f(f(f(f(f(f(f(f(f(f(f( ...</strong></p>
</a>

<p><a href="javascript:fa('2_10')">Посмотреть ответ</a></p>

<h4>Резюме</h4>

<p><a name="tn339">К настоящему моменту мы изучили нечто
вроде базового Пролога, который называют еще <span
id="t339">&quot;чистый Пролог&quot;</span>. Он &quot;чист&quot;,
потому что довольно точно соответствует
формальной логике. Расширения, преследующие цель
приспособить язык к некоторым практическим
нуждам, будут изучены дальше (гл. 3, 5, 6. 7). Важными
моментами данной главы являются следующие: 

<ul>
  <li>Простые объекты в Прологе - это <em>атомы</em>, <em>переменные</em>
    и <em>числа</em>. Структурные объекты, или <em>структуры</em>,
    используются для представления объектов,
    которые состоят из нескольких компонент.</li>
  <li>Структуры строятся посредством <em>функторов</em>.
    Каждый функтор определяется своими именем и
    арностью.</li>
  <li>Тип объекта распознается исключительно по его
    синтаксической форме.</li>
  <li><em>Область известности (лексический диапазон)</em>
    переменных - одно предложение. Поэтому одно и то
    же имя в двух предложениях обозначает две разные
    переменные.</li>
  <li>Структуры могут быть естественным образом
    изображены в виде деревьев. Пролог можно
    рассматривать как язык обработки деревьев.</li>
  <li>Операция <em>сопоставление</em> берет два терма и
    пытается сделать их идентичными, подбирая
    соответствующую конкретизацию переменных в
    обоих термах.</li>
  <li>Сопоставление, если оно завершается успешно, в
    качестве результата выдает <em>наиболее общую</em>
    конкретизацию переменных.</li>
  <li><em>Декларативная семантика</em> Пролога
    определяет, является ли целевое утверждение
    истинным, исходя из данной программы, и если оно
    истинно, то для какой конкретизации переменных.</li>
  <li>Запятая между целями означает их конъюнкцию.
    Точка с запятой между целями означает их
    дизъюнкцию.</li>
  <li><em>Процедурная семантика</em> Пролога - это
    процедура достижения списка целей в контексте
    данной программы. Процедура выдает истинность
    или ложность списка целей и соответствующую
    конкретизацию переменных. Процедура
    осуществляет автоматический возврат для
    перебора различных вариантов.</li>
  <li>Декларативный смысл программ на &quot;чистом
    Прологе&quot; не зависит от порядка предложений и
    от порядка целей в предложениях.</li>
  <li>Процедурный смысл существенно зависит от
    порядка целей и предложений. Поэтому порядок
    может повлиять на эффективность программы;
    неудачный порядок может даже привести к
    бесконечным рекурсивным вызовам.</li>
  <li>Имея декларативно правильную программу, можно
    улучшить ее эффективность путем изменения
    порядка предложений и целей при сохранении ее
    декларативной правильности. Переупорядочивание
    - один из методов предотвращения зацикливания.</li>
  <li>Кроме переупорядочивания существуют и другие,
    более общие методы предотвращения зацикливания,
    способствующие получению процедурно правильных
    программ.</li>
  <li>В данной главе обсуждались следующие понятия:<br>
    <br>
    объекты данных:<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; атом, число, переменная,
    структура<br>
    терм<br>
    функтор, арность функтора<br>
    главный функтор терма<br>
    сопоставление термов<br>
    наиболее общая конкретизация<br>
    декларативная семантика<br>
    конкретизация предложений,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вариант предложения<br>
    процедурная семантика<br>
    вычисление целевого утверждения</li>
</ul>

<h4>Литература</h4>

<p>Clocksin W. F. and Mellish С. S. (1981). <em>Programming in Prolog.</em>
Springer-Verlag. [Имеется перевод: Клоксин У., Меллиш К.
Программирование на языке Пролог. - М.: Мир, 1987.] </p>

<p>Lloyd J. W. (1984). <em>Foundations of Logic Programming.</em> Springer-Verlag.</p>

<p>Nilsson N. J. (1981). <em>Principies of Artificial Intelligence.</em> Tioga;
Springer-Verlag.</p>

<p>Robinson A. J. (1965). <em>A machine-oriented logic based on the resolution principle.
JACM </em><strong>12:</strong> 23-41. [Имеется перевод: Робинсон
Дж. Машинно-ориентированная логика, основанная
на принципе резолюции.- В кн. Кибернетический
сборник, вып. 7, 1970, с. 194-218.]</p>

<hr>
</a>

<p align="center"><a href="ch2_6.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch3_1.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>

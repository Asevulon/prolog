<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Глава 1. Пункт 4</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<script src="script.js" type="text/javascript"></script>
</head>

<body bgColor="#fff5ee">

<p align="center"><a href="ch1_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch1_5.htm">Вперёд</a></p>
<script language="JavaScript">double_line();</script>


<h4>1. 4.&nbsp;&nbsp;&nbsp; Как пролог-система отвечает на
вопросы</h4>

<p>В данном разделе приводится неформальное
объяснение того, <em>как</em> пролог-система
отвечает на вопросы.</p>

<p>Вопрос к системе - это всегда
последовательность, состоящая из одной или
нескольких целей. Для того, чтобы ответить на
вопрос, система пытается достичь всех целей. Что
значит достичь цели? Достичь цели - это значит
показать, что утверждения, содержащиеся в
вопросе, истинны в предположении, что все
отношения программы истинны. Другими <a name="tn331">словами,
достичь цели - это значит показать, что она <span
id="t331"><em>логически</em> следует</span> из фактов и
правил программы. Если вопрос содержит
переменные, система должна к тому же найти
конкретные объекты, которые (будучи
подставленными вместо переменных) обеспечивают
достижение цели. Найденные конкретизации
сообщаются пользователю. Если для некоторой
конкретизации система не в состоянии вывести
цель из остальных предложений программы, то ее
ответом на вопрос будет &quot;нет&quot;.</p>

<p>Таким образом, подходящей интерпретацией
пролог-программы в математических терминах
будет следующая: пролог-система рассматривает
факты и правила в качестве множества аксиом, а
вопрос пользователя - как <em>теорему</em>; затем она
пытается доказать эту теорему, т.е. показать, что
ее можно логически вывести из аксиом. </p>

<p>Проиллюстрируем этот подход на классическом
примере. Пусть имеются следующие аксиомы:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Все люди смертны.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Сократ - человек.</p>

<p>Теорема, логически вытекающая из этих двух
аксиом:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Сократ смертен.</p>

<p>Первую из вышеуказанных аксиом можно
переписать так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Для всех X, если X -
человек, то X смертен.</p>

<p>Соответственно наш пример можно перевести на
Пролог следующим образом:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> смертен( X) :- человек( X).</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Все люди смертны</small><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> человек( сократ).</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Сократ - человек</small><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> ?-&nbsp; смертен( сократ).</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<small>% Сократ смертен?</small><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> yes</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(да)</p>

<p>Более сложный пример из программы о
родственных отношениях, приведенной на рис. 1.8:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> ?-&nbsp; предок( том, пат)</strong></p>

<p>Мы знаем, что <strong>родитель( боб, пат)</strong> - это
факт. Используя этот факт и правило <em>пр1</em>, мы
можем сделать вывод, что утверждение <strong>предок(
боб, пат)</strong> истинно. Этот факт получен в
результате <em>вывода</em> - его нельзя найти
непосредственно в программе, но можно вывести,
пользуясь содержащимися в ней фактами и
правилами. Подобный шаг вывода можно коротко
записать</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> родитель( боб, пат) ==&gt;
предок( боб, пат)</strong></p>

<p>Эту запись можно прочитать так: из <strong>родитель(
боб, пат)</strong> следует <strong>предок( боб, пат)</strong>
на основании правила <em>пр1</em>. Далее, нам известен
факт <strong>родитель( том, боб)</strong>. На основании
этого факта и выведенного факта <strong>предок( боб,
пат)</strong> можно заключить, что, в силу правила <em>пр2</em>,
наше целевое утверждение <strong>предок( том, пат)</strong>
истинно. Весь процесс вывода, состоящий из двух
шагов, можно записать так:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> родитель(боб, пат) ==&gt;
предок( боб, пат)</strong></p>

<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель(том, боб)</strong>&nbsp;
<em> и</em> &nbsp; <strong>предок( боб, пат)&nbsp;&nbsp;&nbsp; ==&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; предок( том, пат)</strong></p>

<p>Таким образом, мы показали, <em>какой</em> может
быть последовательность шагов для достижения
цели, т.е. для демонстрации истинности целевого
утверждения. Назовем такую последовательность
цепочкой доказательства. Однако мы еще не
показали как пролог-система в действительности
строит такую цепочку. </p>

<p>Пролог-система строит цепочку доказательства в
порядке, обратном по отношению к тому, которым мы
только что воспользовались. Вместо того, чтобы
начинать с простых фактов, приведенных в
программе, система начинает с целей и, применяя
правила, подменяет текущие цели новыми, до тех
пор, пока эти новые цели не окажутся простыми
фактами. Если задан вопрос</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> ?-&nbsp; предок( том, пат).</strong></p>

<p>система попытается достичь этой цели. Для того,
чтобы это сделать, она пробует найти такое
предложение в программе, из которого немедленно
следует упомянутая цель. Очевидно, единственными
подходящими для этого предложениями являются <em>пр1</em>
и <em>пр2</em>. </p>
</a>

<p align="center"><img src="pic/fig1_9.gif" width="214" height="184"
alt="fig1_9.gif (1079 bytes)"></p>
<a name="tn331">

<p align="center"><small><strong>Рис. 1. 9.</strong>&nbsp; Первый шаг
вычислений. Верхняя цель истинна, если истинна
нижняя.</small></p>

<p>Это правила, входящие в отношение предок. Будем
говорить, что головы этих правил сопоставимы с
целью.</p>

<p>Два предложения <em>пр1</em> и <em>пр2</em> описывают
два варианта продолжения рассуждений для
пролог-системы. Вначале система пробует
предложение, стоящее в программе первым:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> предок( X, Z) :- родитель(
X, Z).</strong></p>

<p>Поскольку цель - <strong>предок( том, пат)</strong>,
значения переменным должны быть приписаны
следующим образом:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> X&nbsp; =&nbsp; том,&nbsp; Z&nbsp; =
&nbsp; пат</strong></p>

<p>Тогда исходная цель <strong>предок( том, пат)</strong>
заменяется новой целью:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> родитель( том, пат)</strong></p>

<p>Такое действие по замене одной цели на другую
на основании некоторого правила показано на рис.
1.9. В программе нет правила, голова которого была
бы сопоставима с целью <strong>родитель(том, пат)</strong>,
поэтому такая цель оказывается неуспешной.
Теперь система делает <em>возврат</em> к исходной
цели, чтобы попробовать второй вариант вывода
цели верхнего уровня <strong>предок( том, пат)</strong>.
То есть, пробуется правило <em>пр2</em>:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> предок( X, Z) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X, Y),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; предок( Y, Z).</strong></p>

<p>Как и раньше, переменным X и Z приписываются
значения:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> X&nbsp; =&nbsp; том,&nbsp;&nbsp; Z
&nbsp; =&nbsp; пат</strong></p>

<p>В этот момент переменной Y еще не приписано
никакого значения. Верхняя цель <strong>предок( том,
пат)</strong> заменяется двумя целями:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> родитель( том, Y),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; предок( Y, пат)</strong></p>

<p>Этот шаг вычислений показан на рис. 1.10, который
представляет развитие ситуации, изображенной на
рис. 1.9.</p>

<p align="center"><img src="pic/fig1_10.gif" width="383" height="190"
alt="fig1_10.gif (1901 bytes)"></p>

<p align="center"><small><strong>Рис. 1. 10.</strong>&nbsp; Продолжение
процесса вычислений, показанного на рис. 1.9.</small></p>

<p>Имея теперь перед </a><a name="tn274">собой <em>две</em>
цели, система пытается достичь их в том порядке,
каком они</a> записаны. Достичь первой из них
легко, поскольку она <span id="t274">соответствует</span>
факту из программы. Процесс установления
соответствия - сопоставление (унификация)
вызывает приписывание переменной Y значения <strong>боб</strong>.
Тем самым достигается первая цель, а оставшаяся
превращается в</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> предок( боб, пат)</strong></p>

<p>Для достижения этой цели вновь применяется
правило <em>пр1</em>. Заметим, - что это (второе)
применение правила никак не связано с его первым
применением. Поэтому система использует новое
множество переменных правила всякий раз, как оно
применяется. Чтобы указать это, мы переименуем
переменные правила <em>пр1</em> для нового его
применения следующим образом:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> предок( X ', Z ') :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; родитель( X ', Z ').</strong></p>

<p>Голова этого правила должна соответствовать
нашей текущей цели <strong>предок( боб, пат)</strong>.
Поэтому</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> X '&nbsp; =&nbsp; боб,&nbsp;&nbsp; Z '
&nbsp; =&nbsp; пат</strong></p>

<p>Текущая цель заменяется на</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong> родитель( боб, пат)</strong></p>

<p>Такая цель немедленно достигается, поскольку
встречается в программе в качестве факта. Этот
шаг завершает вычисление, что графически
показано на рис. 1.11.</p>

<p align="center"><img src="pic/fig1_11.gif" width="424" height="426"
alt="fig1_11.gif (3476 bytes)"></p>

<p align="center"><small><strong>Рис. 1. 11.</strong>&nbsp; Все шаги
достижения цели <strong>предок( том, пат)</strong>. Правая</small><br>
<small>ветвь демонстрирует, что цель достижима.</small></p>

<p>Графическое представление шагов вычисления на
рис. 1.11 имеет форму дерева. Вершины дерева
соответствуют целям или спискам целей, которые
требуется достичь. Дуги между вершинами
соответствуют применению (альтернативных)
предложений программы, которые преобразуют цель,
соответствующую одной вершине, в цель,
соответствующую другой вершине. Корневая
(верхняя) цель достигается тогда, когда находится
путь от корня дерева (верхней вершины) к его
листу, помеченному меткой &quot;да&quot;. Лист
помечается меткой &quot;да&quot;, если он представляет
собой простой факт. Выполнение пролог-программы
состоит в поиске таких путей. В процессе такого
поиска система может входить и в ветви,
приводящие к неуспеху. <a name="tn3">В тот момент, когда
она обнаруживает, что ветвь не приводит к успеху,
происходит <span id="t3">автоматический <em>возврат</em></span>
к предыдущей вершине, и далее следует попытка
применить к ней альтернативное предложение.</p>

<h4>Упражнение</h4>

<p><strong>1. 7.</strong>&nbsp;&nbsp;&nbsp; Постарайтесь понять, как
пролог-система, используя программу, приведенную
на рис. 1.8, выводит ответы на указанные ниже
вопросы. Попытайтесь нарисовать соответствующие
диаграммы вывода по типу тех, что изображены на
рис.1.9 -1.11. Будут ли встречаться возвраты при
выводе ответов на какие-либо из этих вопросов?</p>

<p>&nbsp;&nbsp;&nbsp; (a)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <strong>?-
&nbsp; родитель( пам, боб).</strong></p>

<p>&nbsp;&nbsp;&nbsp; (b)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <strong>?-&nbsp; мать(
пам, боб).</strong></p>

<p>&nbsp;&nbsp;&nbsp; (с)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <strong>?-
&nbsp; родительродителя( пам, энн).</strong></p>

<p>&nbsp;&nbsp;&nbsp; (d)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <strong>?-
&nbsp; родительродителя( боб, джим).</strong></p>
</a>

<p><a href="javascript:fa('1_7')">Посмотреть ответ</a></p>

<hr>

<p align="center"><a href="ch1_3.htm">Назад</a> | <a href="index.htm">Содержание</a>
| <a href="ch1_5.htm">Вперёд</a></p>
</body>
<script language="JavaScript">

hl();

</script>

</html>
